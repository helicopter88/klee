// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Cache.proto

#ifndef PROTOBUF_Cache_2eproto__INCLUDED
#define PROTOBUF_Cache_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_Cache_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsProtoArrayImpl();
void InitDefaultsProtoArray();
void InitDefaultsProtoBitVectorImpl();
void InitDefaultsProtoBitVector();
void InitDefaultsProtoAssignmentImpl();
void InitDefaultsProtoAssignment();
void InitDefaultsProtoConstExprImpl();
void InitDefaultsProtoConstExpr();
void InitDefaultsNothingImpl();
void InitDefaultsNothing();
void InitDefaultsProtoCacheElemImpl();
void InitDefaultsProtoCacheElem();
void InitDefaultsProtoCacheImpl();
void InitDefaultsProtoCache();
inline void InitDefaults() {
  InitDefaultsProtoArray();
  InitDefaultsProtoBitVector();
  InitDefaultsProtoAssignment();
  InitDefaultsProtoConstExpr();
  InitDefaultsNothing();
  InitDefaultsProtoCacheElem();
  InitDefaultsProtoCache();
}
}  // namespace protobuf_Cache_2eproto
namespace klee {
class Nothing;
class NothingDefaultTypeInternal;
extern NothingDefaultTypeInternal _Nothing_default_instance_;
class ProtoArray;
class ProtoArrayDefaultTypeInternal;
extern ProtoArrayDefaultTypeInternal _ProtoArray_default_instance_;
class ProtoAssignment;
class ProtoAssignmentDefaultTypeInternal;
extern ProtoAssignmentDefaultTypeInternal _ProtoAssignment_default_instance_;
class ProtoBitVector;
class ProtoBitVectorDefaultTypeInternal;
extern ProtoBitVectorDefaultTypeInternal _ProtoBitVector_default_instance_;
class ProtoCache;
class ProtoCacheDefaultTypeInternal;
extern ProtoCacheDefaultTypeInternal _ProtoCache_default_instance_;
class ProtoCacheElem;
class ProtoCacheElemDefaultTypeInternal;
extern ProtoCacheElemDefaultTypeInternal _ProtoCacheElem_default_instance_;
class ProtoConstExpr;
class ProtoConstExprDefaultTypeInternal;
extern ProtoConstExprDefaultTypeInternal _ProtoConstExpr_default_instance_;
class ProtoExpr;
class ProtoExprDefaultTypeInternal;
extern ProtoExprDefaultTypeInternal _ProtoExpr_default_instance_;
class ProtoExtractExpr;
class ProtoExtractExprDefaultTypeInternal;
extern ProtoExtractExprDefaultTypeInternal _ProtoExtractExpr_default_instance_;
class ProtoNotOptimizedExpr;
class ProtoNotOptimizedExprDefaultTypeInternal;
extern ProtoNotOptimizedExprDefaultTypeInternal _ProtoNotOptimizedExpr_default_instance_;
class ProtoReadExpr;
class ProtoReadExprDefaultTypeInternal;
extern ProtoReadExprDefaultTypeInternal _ProtoReadExpr_default_instance_;
class ProtoUpdateNode;
class ProtoUpdateNodeDefaultTypeInternal;
extern ProtoUpdateNodeDefaultTypeInternal _ProtoUpdateNode_default_instance_;
}  // namespace klee
namespace klee {

// ===================================================================

class ProtoArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:klee.ProtoArray) */ {
 public:
  ProtoArray();
  virtual ~ProtoArray();

  ProtoArray(const ProtoArray& from);

  inline ProtoArray& operator=(const ProtoArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoArray(ProtoArray&& from) noexcept
    : ProtoArray() {
    *this = ::std::move(from);
  }

  inline ProtoArray& operator=(ProtoArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoArray& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoArray* internal_default_instance() {
    return reinterpret_cast<const ProtoArray*>(
               &_ProtoArray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ProtoArray* other);
  friend void swap(ProtoArray& a, ProtoArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoArray* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoArray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtoArray& from);
  void MergeFrom(const ProtoArray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtoArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .klee.ProtoExpr constantValues = 5;
  int constantvalues_size() const;
  void clear_constantvalues();
  static const int kConstantValuesFieldNumber = 5;
  const ::klee::ProtoExpr& constantvalues(int index) const;
  ::klee::ProtoExpr* mutable_constantvalues(int index);
  ::klee::ProtoExpr* add_constantvalues();
  ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr >*
      mutable_constantvalues();
  const ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr >&
      constantvalues() const;

  // bytes name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // uint64 size = 2;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // uint32 domain = 3;
  void clear_domain();
  static const int kDomainFieldNumber = 3;
  ::google::protobuf::uint32 domain() const;
  void set_domain(::google::protobuf::uint32 value);

  // uint32 range = 4;
  void clear_range();
  static const int kRangeFieldNumber = 4;
  ::google::protobuf::uint32 range() const;
  void set_range(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:klee.ProtoArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr > constantvalues_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::uint32 domain_;
  ::google::protobuf::uint32 range_;
  mutable int _cached_size_;
  friend struct ::protobuf_Cache_2eproto::TableStruct;
  friend void ::protobuf_Cache_2eproto::InitDefaultsProtoArrayImpl();
};
// -------------------------------------------------------------------

class ProtoBitVector : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:klee.ProtoBitVector) */ {
 public:
  ProtoBitVector();
  virtual ~ProtoBitVector();

  ProtoBitVector(const ProtoBitVector& from);

  inline ProtoBitVector& operator=(const ProtoBitVector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoBitVector(ProtoBitVector&& from) noexcept
    : ProtoBitVector() {
    *this = ::std::move(from);
  }

  inline ProtoBitVector& operator=(ProtoBitVector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoBitVector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoBitVector* internal_default_instance() {
    return reinterpret_cast<const ProtoBitVector*>(
               &_ProtoBitVector_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ProtoBitVector* other);
  friend void swap(ProtoBitVector& a, ProtoBitVector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoBitVector* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoBitVector* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtoBitVector& from);
  void MergeFrom(const ProtoBitVector& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtoBitVector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated fixed32 values = 6;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 6;
  ::google::protobuf::uint32 values(int index) const;
  void set_values(int index, ::google::protobuf::uint32 value);
  void add_values(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      values() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:klee.ProtoBitVector)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > values_;
  mutable int _values_cached_byte_size_;
  mutable int _cached_size_;
  friend struct ::protobuf_Cache_2eproto::TableStruct;
  friend void ::protobuf_Cache_2eproto::InitDefaultsProtoBitVectorImpl();
};
// -------------------------------------------------------------------

class ProtoAssignment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:klee.ProtoAssignment) */ {
 public:
  ProtoAssignment();
  virtual ~ProtoAssignment();

  ProtoAssignment(const ProtoAssignment& from);

  inline ProtoAssignment& operator=(const ProtoAssignment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoAssignment(ProtoAssignment&& from) noexcept
    : ProtoAssignment() {
    *this = ::std::move(from);
  }

  inline ProtoAssignment& operator=(ProtoAssignment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoAssignment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoAssignment* internal_default_instance() {
    return reinterpret_cast<const ProtoAssignment*>(
               &_ProtoAssignment_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ProtoAssignment* other);
  friend void swap(ProtoAssignment& a, ProtoAssignment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoAssignment* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoAssignment* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtoAssignment& from);
  void MergeFrom(const ProtoAssignment& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtoAssignment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .klee.ProtoArray objects = 8;
  int objects_size() const;
  void clear_objects();
  static const int kObjectsFieldNumber = 8;
  const ::klee::ProtoArray& objects(int index) const;
  ::klee::ProtoArray* mutable_objects(int index);
  ::klee::ProtoArray* add_objects();
  ::google::protobuf::RepeatedPtrField< ::klee::ProtoArray >*
      mutable_objects();
  const ::google::protobuf::RepeatedPtrField< ::klee::ProtoArray >&
      objects() const;

  // repeated .klee.ProtoBitVector bvs = 9;
  int bvs_size() const;
  void clear_bvs();
  static const int kBvsFieldNumber = 9;
  const ::klee::ProtoBitVector& bvs(int index) const;
  ::klee::ProtoBitVector* mutable_bvs(int index);
  ::klee::ProtoBitVector* add_bvs();
  ::google::protobuf::RepeatedPtrField< ::klee::ProtoBitVector >*
      mutable_bvs();
  const ::google::protobuf::RepeatedPtrField< ::klee::ProtoBitVector >&
      bvs() const;

  // bool allowFreeValues = 7;
  void clear_allowfreevalues();
  static const int kAllowFreeValuesFieldNumber = 7;
  bool allowfreevalues() const;
  void set_allowfreevalues(bool value);

  // bool noBinding = 10;
  void clear_nobinding();
  static const int kNoBindingFieldNumber = 10;
  bool nobinding() const;
  void set_nobinding(bool value);

  // @@protoc_insertion_point(class_scope:klee.ProtoAssignment)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::klee::ProtoArray > objects_;
  ::google::protobuf::RepeatedPtrField< ::klee::ProtoBitVector > bvs_;
  bool allowfreevalues_;
  bool nobinding_;
  mutable int _cached_size_;
  friend struct ::protobuf_Cache_2eproto::TableStruct;
  friend void ::protobuf_Cache_2eproto::InitDefaultsProtoAssignmentImpl();
};
// -------------------------------------------------------------------

class ProtoConstExpr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:klee.ProtoConstExpr) */ {
 public:
  ProtoConstExpr();
  virtual ~ProtoConstExpr();

  ProtoConstExpr(const ProtoConstExpr& from);

  inline ProtoConstExpr& operator=(const ProtoConstExpr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoConstExpr(ProtoConstExpr&& from) noexcept
    : ProtoConstExpr() {
    *this = ::std::move(from);
  }

  inline ProtoConstExpr& operator=(ProtoConstExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoConstExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoConstExpr* internal_default_instance() {
    return reinterpret_cast<const ProtoConstExpr*>(
               &_ProtoConstExpr_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ProtoConstExpr* other);
  friend void swap(ProtoConstExpr& a, ProtoConstExpr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoConstExpr* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoConstExpr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtoConstExpr& from);
  void MergeFrom(const ProtoConstExpr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtoConstExpr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string constExprValStr = 350;
  void clear_constexprvalstr();
  static const int kConstExprValStrFieldNumber = 350;
  const ::std::string& constexprvalstr() const;
  void set_constexprvalstr(const ::std::string& value);
  #if LANG_CXX11
  void set_constexprvalstr(::std::string&& value);
  #endif
  void set_constexprvalstr(const char* value);
  void set_constexprvalstr(const char* value, size_t size);
  ::std::string* mutable_constexprvalstr();
  ::std::string* release_constexprvalstr();
  void set_allocated_constexprvalstr(::std::string* constexprvalstr);

  // uint32 constExprBWidth = 11;
  void clear_constexprbwidth();
  static const int kConstExprBWidthFieldNumber = 11;
  ::google::protobuf::uint32 constexprbwidth() const;
  void set_constexprbwidth(::google::protobuf::uint32 value);

  // uint64 constExprVal = 12;
  void clear_constexprval();
  static const int kConstExprValFieldNumber = 12;
  ::google::protobuf::uint64 constexprval() const;
  void set_constexprval(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:klee.ProtoConstExpr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr constexprvalstr_;
  ::google::protobuf::uint32 constexprbwidth_;
  ::google::protobuf::uint64 constexprval_;
  mutable int _cached_size_;
  friend struct ::protobuf_Cache_2eproto::TableStruct;
  friend void ::protobuf_Cache_2eproto::InitDefaultsProtoConstExprImpl();
};
// -------------------------------------------------------------------

class ProtoUpdateNode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:klee.ProtoUpdateNode) */ {
 public:
  ProtoUpdateNode();
  virtual ~ProtoUpdateNode();

  ProtoUpdateNode(const ProtoUpdateNode& from);

  inline ProtoUpdateNode& operator=(const ProtoUpdateNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoUpdateNode(ProtoUpdateNode&& from) noexcept
    : ProtoUpdateNode() {
    *this = ::std::move(from);
  }

  inline ProtoUpdateNode& operator=(ProtoUpdateNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoUpdateNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoUpdateNode* internal_default_instance() {
    return reinterpret_cast<const ProtoUpdateNode*>(
               &_ProtoUpdateNode_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ProtoUpdateNode* other);
  friend void swap(ProtoUpdateNode& a, ProtoUpdateNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoUpdateNode* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoUpdateNode* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtoUpdateNode& from);
  void MergeFrom(const ProtoUpdateNode& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtoUpdateNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .klee.ProtoExpr updateIndex = 13;
  bool has_updateindex() const;
  void clear_updateindex();
  static const int kUpdateIndexFieldNumber = 13;
  const ::klee::ProtoExpr& updateindex() const;
  ::klee::ProtoExpr* release_updateindex();
  ::klee::ProtoExpr* mutable_updateindex();
  void set_allocated_updateindex(::klee::ProtoExpr* updateindex);

  // .klee.ProtoExpr updateValue = 14;
  bool has_updatevalue() const;
  void clear_updatevalue();
  static const int kUpdateValueFieldNumber = 14;
  const ::klee::ProtoExpr& updatevalue() const;
  ::klee::ProtoExpr* release_updatevalue();
  ::klee::ProtoExpr* mutable_updatevalue();
  void set_allocated_updatevalue(::klee::ProtoExpr* updatevalue);

  // .klee.ProtoUpdateNode next = 15;
  bool has_next() const;
  void clear_next();
  static const int kNextFieldNumber = 15;
  const ::klee::ProtoUpdateNode& next() const;
  ::klee::ProtoUpdateNode* release_next();
  ::klee::ProtoUpdateNode* mutable_next();
  void set_allocated_next(::klee::ProtoUpdateNode* next);

  // @@protoc_insertion_point(class_scope:klee.ProtoUpdateNode)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::klee::ProtoExpr* updateindex_;
  ::klee::ProtoExpr* updatevalue_;
  ::klee::ProtoUpdateNode* next_;
  mutable int _cached_size_;
  friend struct ::protobuf_Cache_2eproto::TableStruct;
  friend void ::protobuf_Cache_2eproto::InitDefaultsProtoArrayImpl();
};
// -------------------------------------------------------------------

class ProtoReadExpr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:klee.ProtoReadExpr) */ {
 public:
  ProtoReadExpr();
  virtual ~ProtoReadExpr();

  ProtoReadExpr(const ProtoReadExpr& from);

  inline ProtoReadExpr& operator=(const ProtoReadExpr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoReadExpr(ProtoReadExpr&& from) noexcept
    : ProtoReadExpr() {
    *this = ::std::move(from);
  }

  inline ProtoReadExpr& operator=(ProtoReadExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoReadExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoReadExpr* internal_default_instance() {
    return reinterpret_cast<const ProtoReadExpr*>(
               &_ProtoReadExpr_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ProtoReadExpr* other);
  friend void swap(ProtoReadExpr& a, ProtoReadExpr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoReadExpr* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoReadExpr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtoReadExpr& from);
  void MergeFrom(const ProtoReadExpr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtoReadExpr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .klee.ProtoUpdateNode head = 16;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 16;
  const ::klee::ProtoUpdateNode& head() const;
  ::klee::ProtoUpdateNode* release_head();
  ::klee::ProtoUpdateNode* mutable_head();
  void set_allocated_head(::klee::ProtoUpdateNode* head);

  // .klee.ProtoArray root = 17;
  bool has_root() const;
  void clear_root();
  static const int kRootFieldNumber = 17;
  const ::klee::ProtoArray& root() const;
  ::klee::ProtoArray* release_root();
  ::klee::ProtoArray* mutable_root();
  void set_allocated_root(::klee::ProtoArray* root);

  // .klee.ProtoExpr expr = 18;
  bool has_expr() const;
  void clear_expr();
  static const int kExprFieldNumber = 18;
  const ::klee::ProtoExpr& expr() const;
  ::klee::ProtoExpr* release_expr();
  ::klee::ProtoExpr* mutable_expr();
  void set_allocated_expr(::klee::ProtoExpr* expr);

  // @@protoc_insertion_point(class_scope:klee.ProtoReadExpr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::klee::ProtoUpdateNode* head_;
  ::klee::ProtoArray* root_;
  ::klee::ProtoExpr* expr_;
  mutable int _cached_size_;
  friend struct ::protobuf_Cache_2eproto::TableStruct;
  friend void ::protobuf_Cache_2eproto::InitDefaultsProtoArrayImpl();
};
// -------------------------------------------------------------------

class ProtoExtractExpr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:klee.ProtoExtractExpr) */ {
 public:
  ProtoExtractExpr();
  virtual ~ProtoExtractExpr();

  ProtoExtractExpr(const ProtoExtractExpr& from);

  inline ProtoExtractExpr& operator=(const ProtoExtractExpr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoExtractExpr(ProtoExtractExpr&& from) noexcept
    : ProtoExtractExpr() {
    *this = ::std::move(from);
  }

  inline ProtoExtractExpr& operator=(ProtoExtractExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoExtractExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoExtractExpr* internal_default_instance() {
    return reinterpret_cast<const ProtoExtractExpr*>(
               &_ProtoExtractExpr_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ProtoExtractExpr* other);
  friend void swap(ProtoExtractExpr& a, ProtoExtractExpr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoExtractExpr* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoExtractExpr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtoExtractExpr& from);
  void MergeFrom(const ProtoExtractExpr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtoExtractExpr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .klee.ProtoExpr expr = 21;
  bool has_expr() const;
  void clear_expr();
  static const int kExprFieldNumber = 21;
  const ::klee::ProtoExpr& expr() const;
  ::klee::ProtoExpr* release_expr();
  ::klee::ProtoExpr* mutable_expr();
  void set_allocated_expr(::klee::ProtoExpr* expr);

  // uint32 extractBitOff = 19;
  void clear_extractbitoff();
  static const int kExtractBitOffFieldNumber = 19;
  ::google::protobuf::uint32 extractbitoff() const;
  void set_extractbitoff(::google::protobuf::uint32 value);

  // uint32 extractWidth = 20;
  void clear_extractwidth();
  static const int kExtractWidthFieldNumber = 20;
  ::google::protobuf::uint32 extractwidth() const;
  void set_extractwidth(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:klee.ProtoExtractExpr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::klee::ProtoExpr* expr_;
  ::google::protobuf::uint32 extractbitoff_;
  ::google::protobuf::uint32 extractwidth_;
  mutable int _cached_size_;
  friend struct ::protobuf_Cache_2eproto::TableStruct;
  friend void ::protobuf_Cache_2eproto::InitDefaultsProtoArrayImpl();
};
// -------------------------------------------------------------------

class ProtoNotOptimizedExpr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:klee.ProtoNotOptimizedExpr) */ {
 public:
  ProtoNotOptimizedExpr();
  virtual ~ProtoNotOptimizedExpr();

  ProtoNotOptimizedExpr(const ProtoNotOptimizedExpr& from);

  inline ProtoNotOptimizedExpr& operator=(const ProtoNotOptimizedExpr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoNotOptimizedExpr(ProtoNotOptimizedExpr&& from) noexcept
    : ProtoNotOptimizedExpr() {
    *this = ::std::move(from);
  }

  inline ProtoNotOptimizedExpr& operator=(ProtoNotOptimizedExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoNotOptimizedExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoNotOptimizedExpr* internal_default_instance() {
    return reinterpret_cast<const ProtoNotOptimizedExpr*>(
               &_ProtoNotOptimizedExpr_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ProtoNotOptimizedExpr* other);
  friend void swap(ProtoNotOptimizedExpr& a, ProtoNotOptimizedExpr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoNotOptimizedExpr* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoNotOptimizedExpr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtoNotOptimizedExpr& from);
  void MergeFrom(const ProtoNotOptimizedExpr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtoNotOptimizedExpr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .klee.ProtoExpr src = 22;
  bool has_src() const;
  void clear_src();
  static const int kSrcFieldNumber = 22;
  const ::klee::ProtoExpr& src() const;
  ::klee::ProtoExpr* release_src();
  ::klee::ProtoExpr* mutable_src();
  void set_allocated_src(::klee::ProtoExpr* src);

  // @@protoc_insertion_point(class_scope:klee.ProtoNotOptimizedExpr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::klee::ProtoExpr* src_;
  mutable int _cached_size_;
  friend struct ::protobuf_Cache_2eproto::TableStruct;
  friend void ::protobuf_Cache_2eproto::InitDefaultsProtoArrayImpl();
};
// -------------------------------------------------------------------

class Nothing : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:klee.Nothing) */ {
 public:
  Nothing();
  virtual ~Nothing();

  Nothing(const Nothing& from);

  inline Nothing& operator=(const Nothing& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Nothing(Nothing&& from) noexcept
    : Nothing() {
    *this = ::std::move(from);
  }

  inline Nothing& operator=(Nothing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Nothing& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Nothing* internal_default_instance() {
    return reinterpret_cast<const Nothing*>(
               &_Nothing_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Nothing* other);
  friend void swap(Nothing& a, Nothing& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Nothing* New() const PROTOBUF_FINAL { return New(NULL); }

  Nothing* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Nothing& from);
  void MergeFrom(const Nothing& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Nothing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:klee.Nothing)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_Cache_2eproto::TableStruct;
  friend void ::protobuf_Cache_2eproto::InitDefaultsNothingImpl();
};
// -------------------------------------------------------------------

class ProtoExpr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:klee.ProtoExpr) */ {
 public:
  ProtoExpr();
  virtual ~ProtoExpr();

  ProtoExpr(const ProtoExpr& from);

  inline ProtoExpr& operator=(const ProtoExpr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoExpr(ProtoExpr&& from) noexcept
    : ProtoExpr() {
    *this = ::std::move(from);
  }

  inline ProtoExpr& operator=(ProtoExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoExpr& default_instance();

  enum SpecialDataCase {
    kConstData = 50,
    kReadData = 52,
    kExtractData = 152,
    kNOData = 153,
    kE = 155,
    SPECIALDATA_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoExpr* internal_default_instance() {
    return reinterpret_cast<const ProtoExpr*>(
               &_ProtoExpr_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(ProtoExpr* other);
  friend void swap(ProtoExpr& a, ProtoExpr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoExpr* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoExpr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtoExpr& from);
  void MergeFrom(const ProtoExpr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtoExpr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .klee.ProtoExpr kids = 25;
  int kids_size() const;
  void clear_kids();
  static const int kKidsFieldNumber = 25;
  const ::klee::ProtoExpr& kids(int index) const;
  ::klee::ProtoExpr* mutable_kids(int index);
  ::klee::ProtoExpr* add_kids();
  ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr >*
      mutable_kids();
  const ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr >&
      kids() const;

  // uint32 width = 23;
  void clear_width();
  static const int kWidthFieldNumber = 23;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // uint32 kind = 24;
  void clear_kind();
  static const int kKindFieldNumber = 24;
  ::google::protobuf::uint32 kind() const;
  void set_kind(::google::protobuf::uint32 value);

  // .klee.ProtoConstExpr constData = 50;
  bool has_constdata() const;
  void clear_constdata();
  static const int kConstDataFieldNumber = 50;
  const ::klee::ProtoConstExpr& constdata() const;
  ::klee::ProtoConstExpr* release_constdata();
  ::klee::ProtoConstExpr* mutable_constdata();
  void set_allocated_constdata(::klee::ProtoConstExpr* constdata);

  // .klee.ProtoReadExpr readData = 52;
  bool has_readdata() const;
  void clear_readdata();
  static const int kReadDataFieldNumber = 52;
  const ::klee::ProtoReadExpr& readdata() const;
  ::klee::ProtoReadExpr* release_readdata();
  ::klee::ProtoReadExpr* mutable_readdata();
  void set_allocated_readdata(::klee::ProtoReadExpr* readdata);

  // .klee.ProtoExtractExpr extractData = 152;
  bool has_extractdata() const;
  void clear_extractdata();
  static const int kExtractDataFieldNumber = 152;
  const ::klee::ProtoExtractExpr& extractdata() const;
  ::klee::ProtoExtractExpr* release_extractdata();
  ::klee::ProtoExtractExpr* mutable_extractdata();
  void set_allocated_extractdata(::klee::ProtoExtractExpr* extractdata);

  // .klee.ProtoNotOptimizedExpr NOData = 153;
  bool has_nodata() const;
  void clear_nodata();
  static const int kNODataFieldNumber = 153;
  const ::klee::ProtoNotOptimizedExpr& nodata() const;
  ::klee::ProtoNotOptimizedExpr* release_nodata();
  ::klee::ProtoNotOptimizedExpr* mutable_nodata();
  void set_allocated_nodata(::klee::ProtoNotOptimizedExpr* nodata);

  // .klee.Nothing e = 155;
  bool has_e() const;
  void clear_e();
  static const int kEFieldNumber = 155;
  const ::klee::Nothing& e() const;
  ::klee::Nothing* release_e();
  ::klee::Nothing* mutable_e();
  void set_allocated_e(::klee::Nothing* e);

  SpecialDataCase specialData_case() const;
  // @@protoc_insertion_point(class_scope:klee.ProtoExpr)
 private:
  void set_has_constdata();
  void set_has_readdata();
  void set_has_extractdata();
  void set_has_nodata();
  void set_has_e();

  inline bool has_specialData() const;
  void clear_specialData();
  inline void clear_has_specialData();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr > kids_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 kind_;
  union SpecialDataUnion {
    SpecialDataUnion() {}
    ::klee::ProtoConstExpr* constdata_;
    ::klee::ProtoReadExpr* readdata_;
    ::klee::ProtoExtractExpr* extractdata_;
    ::klee::ProtoNotOptimizedExpr* nodata_;
    ::klee::Nothing* e_;
  } specialData_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_Cache_2eproto::TableStruct;
  friend void ::protobuf_Cache_2eproto::InitDefaultsProtoArrayImpl();
};
// -------------------------------------------------------------------

class ProtoCacheElem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:klee.ProtoCacheElem) */ {
 public:
  ProtoCacheElem();
  virtual ~ProtoCacheElem();

  ProtoCacheElem(const ProtoCacheElem& from);

  inline ProtoCacheElem& operator=(const ProtoCacheElem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoCacheElem(ProtoCacheElem&& from) noexcept
    : ProtoCacheElem() {
    *this = ::std::move(from);
  }

  inline ProtoCacheElem& operator=(ProtoCacheElem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoCacheElem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoCacheElem* internal_default_instance() {
    return reinterpret_cast<const ProtoCacheElem*>(
               &_ProtoCacheElem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ProtoCacheElem* other);
  friend void swap(ProtoCacheElem& a, ProtoCacheElem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoCacheElem* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoCacheElem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtoCacheElem& from);
  void MergeFrom(const ProtoCacheElem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtoCacheElem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .klee.ProtoExpr key = 156;
  int key_size() const;
  void clear_key();
  static const int kKeyFieldNumber = 156;
  const ::klee::ProtoExpr& key(int index) const;
  ::klee::ProtoExpr* mutable_key(int index);
  ::klee::ProtoExpr* add_key();
  ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr >*
      mutable_key();
  const ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr >&
      key() const;

  // .klee.ProtoAssignment assignment = 300;
  bool has_assignment() const;
  void clear_assignment();
  static const int kAssignmentFieldNumber = 300;
  const ::klee::ProtoAssignment& assignment() const;
  ::klee::ProtoAssignment* release_assignment();
  ::klee::ProtoAssignment* mutable_assignment();
  void set_allocated_assignment(::klee::ProtoAssignment* assignment);

  // @@protoc_insertion_point(class_scope:klee.ProtoCacheElem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr > key_;
  ::klee::ProtoAssignment* assignment_;
  mutable int _cached_size_;
  friend struct ::protobuf_Cache_2eproto::TableStruct;
  friend void ::protobuf_Cache_2eproto::InitDefaultsProtoCacheElemImpl();
};
// -------------------------------------------------------------------

class ProtoCache : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:klee.ProtoCache) */ {
 public:
  ProtoCache();
  virtual ~ProtoCache();

  ProtoCache(const ProtoCache& from);

  inline ProtoCache& operator=(const ProtoCache& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoCache(ProtoCache&& from) noexcept
    : ProtoCache() {
    *this = ::std::move(from);
  }

  inline ProtoCache& operator=(ProtoCache&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoCache& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoCache* internal_default_instance() {
    return reinterpret_cast<const ProtoCache*>(
               &_ProtoCache_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(ProtoCache* other);
  friend void swap(ProtoCache& a, ProtoCache& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoCache* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoCache* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtoCache& from);
  void MergeFrom(const ProtoCache& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtoCache* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .klee.ProtoCacheElem elem = 32;
  int elem_size() const;
  void clear_elem();
  static const int kElemFieldNumber = 32;
  const ::klee::ProtoCacheElem& elem(int index) const;
  ::klee::ProtoCacheElem* mutable_elem(int index);
  ::klee::ProtoCacheElem* add_elem();
  ::google::protobuf::RepeatedPtrField< ::klee::ProtoCacheElem >*
      mutable_elem();
  const ::google::protobuf::RepeatedPtrField< ::klee::ProtoCacheElem >&
      elem() const;

  // @@protoc_insertion_point(class_scope:klee.ProtoCache)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::klee::ProtoCacheElem > elem_;
  mutable int _cached_size_;
  friend struct ::protobuf_Cache_2eproto::TableStruct;
  friend void ::protobuf_Cache_2eproto::InitDefaultsProtoCacheImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ProtoArray

// bytes name = 1;
inline void ProtoArray::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProtoArray::name() const {
  // @@protoc_insertion_point(field_get:klee.ProtoArray.name)
  return name_.GetNoArena();
}
inline void ProtoArray::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:klee.ProtoArray.name)
}
#if LANG_CXX11
inline void ProtoArray::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:klee.ProtoArray.name)
}
#endif
inline void ProtoArray::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:klee.ProtoArray.name)
}
inline void ProtoArray::set_name(const void* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:klee.ProtoArray.name)
}
inline ::std::string* ProtoArray::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:klee.ProtoArray.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoArray::release_name() {
  // @@protoc_insertion_point(field_release:klee.ProtoArray.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoArray::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:klee.ProtoArray.name)
}

// uint64 size = 2;
inline void ProtoArray::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ProtoArray::size() const {
  // @@protoc_insertion_point(field_get:klee.ProtoArray.size)
  return size_;
}
inline void ProtoArray::set_size(::google::protobuf::uint64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:klee.ProtoArray.size)
}

// uint32 domain = 3;
inline void ProtoArray::clear_domain() {
  domain_ = 0u;
}
inline ::google::protobuf::uint32 ProtoArray::domain() const {
  // @@protoc_insertion_point(field_get:klee.ProtoArray.domain)
  return domain_;
}
inline void ProtoArray::set_domain(::google::protobuf::uint32 value) {
  
  domain_ = value;
  // @@protoc_insertion_point(field_set:klee.ProtoArray.domain)
}

// uint32 range = 4;
inline void ProtoArray::clear_range() {
  range_ = 0u;
}
inline ::google::protobuf::uint32 ProtoArray::range() const {
  // @@protoc_insertion_point(field_get:klee.ProtoArray.range)
  return range_;
}
inline void ProtoArray::set_range(::google::protobuf::uint32 value) {
  
  range_ = value;
  // @@protoc_insertion_point(field_set:klee.ProtoArray.range)
}

// repeated .klee.ProtoExpr constantValues = 5;
inline int ProtoArray::constantvalues_size() const {
  return constantvalues_.size();
}
inline void ProtoArray::clear_constantvalues() {
  constantvalues_.Clear();
}
inline const ::klee::ProtoExpr& ProtoArray::constantvalues(int index) const {
  // @@protoc_insertion_point(field_get:klee.ProtoArray.constantValues)
  return constantvalues_.Get(index);
}
inline ::klee::ProtoExpr* ProtoArray::mutable_constantvalues(int index) {
  // @@protoc_insertion_point(field_mutable:klee.ProtoArray.constantValues)
  return constantvalues_.Mutable(index);
}
inline ::klee::ProtoExpr* ProtoArray::add_constantvalues() {
  // @@protoc_insertion_point(field_add:klee.ProtoArray.constantValues)
  return constantvalues_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr >*
ProtoArray::mutable_constantvalues() {
  // @@protoc_insertion_point(field_mutable_list:klee.ProtoArray.constantValues)
  return &constantvalues_;
}
inline const ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr >&
ProtoArray::constantvalues() const {
  // @@protoc_insertion_point(field_list:klee.ProtoArray.constantValues)
  return constantvalues_;
}

// -------------------------------------------------------------------

// ProtoBitVector

// repeated fixed32 values = 6;
inline int ProtoBitVector::values_size() const {
  return values_.size();
}
inline void ProtoBitVector::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::uint32 ProtoBitVector::values(int index) const {
  // @@protoc_insertion_point(field_get:klee.ProtoBitVector.values)
  return values_.Get(index);
}
inline void ProtoBitVector::set_values(int index, ::google::protobuf::uint32 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:klee.ProtoBitVector.values)
}
inline void ProtoBitVector::add_values(::google::protobuf::uint32 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:klee.ProtoBitVector.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ProtoBitVector::values() const {
  // @@protoc_insertion_point(field_list:klee.ProtoBitVector.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ProtoBitVector::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:klee.ProtoBitVector.values)
  return &values_;
}

// -------------------------------------------------------------------

// ProtoAssignment

// bool allowFreeValues = 7;
inline void ProtoAssignment::clear_allowfreevalues() {
  allowfreevalues_ = false;
}
inline bool ProtoAssignment::allowfreevalues() const {
  // @@protoc_insertion_point(field_get:klee.ProtoAssignment.allowFreeValues)
  return allowfreevalues_;
}
inline void ProtoAssignment::set_allowfreevalues(bool value) {
  
  allowfreevalues_ = value;
  // @@protoc_insertion_point(field_set:klee.ProtoAssignment.allowFreeValues)
}

// repeated .klee.ProtoArray objects = 8;
inline int ProtoAssignment::objects_size() const {
  return objects_.size();
}
inline void ProtoAssignment::clear_objects() {
  objects_.Clear();
}
inline const ::klee::ProtoArray& ProtoAssignment::objects(int index) const {
  // @@protoc_insertion_point(field_get:klee.ProtoAssignment.objects)
  return objects_.Get(index);
}
inline ::klee::ProtoArray* ProtoAssignment::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:klee.ProtoAssignment.objects)
  return objects_.Mutable(index);
}
inline ::klee::ProtoArray* ProtoAssignment::add_objects() {
  // @@protoc_insertion_point(field_add:klee.ProtoAssignment.objects)
  return objects_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::klee::ProtoArray >*
ProtoAssignment::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:klee.ProtoAssignment.objects)
  return &objects_;
}
inline const ::google::protobuf::RepeatedPtrField< ::klee::ProtoArray >&
ProtoAssignment::objects() const {
  // @@protoc_insertion_point(field_list:klee.ProtoAssignment.objects)
  return objects_;
}

// repeated .klee.ProtoBitVector bvs = 9;
inline int ProtoAssignment::bvs_size() const {
  return bvs_.size();
}
inline void ProtoAssignment::clear_bvs() {
  bvs_.Clear();
}
inline const ::klee::ProtoBitVector& ProtoAssignment::bvs(int index) const {
  // @@protoc_insertion_point(field_get:klee.ProtoAssignment.bvs)
  return bvs_.Get(index);
}
inline ::klee::ProtoBitVector* ProtoAssignment::mutable_bvs(int index) {
  // @@protoc_insertion_point(field_mutable:klee.ProtoAssignment.bvs)
  return bvs_.Mutable(index);
}
inline ::klee::ProtoBitVector* ProtoAssignment::add_bvs() {
  // @@protoc_insertion_point(field_add:klee.ProtoAssignment.bvs)
  return bvs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::klee::ProtoBitVector >*
ProtoAssignment::mutable_bvs() {
  // @@protoc_insertion_point(field_mutable_list:klee.ProtoAssignment.bvs)
  return &bvs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::klee::ProtoBitVector >&
ProtoAssignment::bvs() const {
  // @@protoc_insertion_point(field_list:klee.ProtoAssignment.bvs)
  return bvs_;
}

// bool noBinding = 10;
inline void ProtoAssignment::clear_nobinding() {
  nobinding_ = false;
}
inline bool ProtoAssignment::nobinding() const {
  // @@protoc_insertion_point(field_get:klee.ProtoAssignment.noBinding)
  return nobinding_;
}
inline void ProtoAssignment::set_nobinding(bool value) {
  
  nobinding_ = value;
  // @@protoc_insertion_point(field_set:klee.ProtoAssignment.noBinding)
}

// -------------------------------------------------------------------

// ProtoConstExpr

// uint32 constExprBWidth = 11;
inline void ProtoConstExpr::clear_constexprbwidth() {
  constexprbwidth_ = 0u;
}
inline ::google::protobuf::uint32 ProtoConstExpr::constexprbwidth() const {
  // @@protoc_insertion_point(field_get:klee.ProtoConstExpr.constExprBWidth)
  return constexprbwidth_;
}
inline void ProtoConstExpr::set_constexprbwidth(::google::protobuf::uint32 value) {
  
  constexprbwidth_ = value;
  // @@protoc_insertion_point(field_set:klee.ProtoConstExpr.constExprBWidth)
}

// uint64 constExprVal = 12;
inline void ProtoConstExpr::clear_constexprval() {
  constexprval_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ProtoConstExpr::constexprval() const {
  // @@protoc_insertion_point(field_get:klee.ProtoConstExpr.constExprVal)
  return constexprval_;
}
inline void ProtoConstExpr::set_constexprval(::google::protobuf::uint64 value) {
  
  constexprval_ = value;
  // @@protoc_insertion_point(field_set:klee.ProtoConstExpr.constExprVal)
}

// string constExprValStr = 350;
inline void ProtoConstExpr::clear_constexprvalstr() {
  constexprvalstr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProtoConstExpr::constexprvalstr() const {
  // @@protoc_insertion_point(field_get:klee.ProtoConstExpr.constExprValStr)
  return constexprvalstr_.GetNoArena();
}
inline void ProtoConstExpr::set_constexprvalstr(const ::std::string& value) {
  
  constexprvalstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:klee.ProtoConstExpr.constExprValStr)
}
#if LANG_CXX11
inline void ProtoConstExpr::set_constexprvalstr(::std::string&& value) {
  
  constexprvalstr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:klee.ProtoConstExpr.constExprValStr)
}
#endif
inline void ProtoConstExpr::set_constexprvalstr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  constexprvalstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:klee.ProtoConstExpr.constExprValStr)
}
inline void ProtoConstExpr::set_constexprvalstr(const char* value, size_t size) {
  
  constexprvalstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:klee.ProtoConstExpr.constExprValStr)
}
inline ::std::string* ProtoConstExpr::mutable_constexprvalstr() {
  
  // @@protoc_insertion_point(field_mutable:klee.ProtoConstExpr.constExprValStr)
  return constexprvalstr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoConstExpr::release_constexprvalstr() {
  // @@protoc_insertion_point(field_release:klee.ProtoConstExpr.constExprValStr)
  
  return constexprvalstr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoConstExpr::set_allocated_constexprvalstr(::std::string* constexprvalstr) {
  if (constexprvalstr != NULL) {
    
  } else {
    
  }
  constexprvalstr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), constexprvalstr);
  // @@protoc_insertion_point(field_set_allocated:klee.ProtoConstExpr.constExprValStr)
}

// -------------------------------------------------------------------

// ProtoUpdateNode

// .klee.ProtoExpr updateIndex = 13;
inline bool ProtoUpdateNode::has_updateindex() const {
  return this != internal_default_instance() && updateindex_ != NULL;
}
inline void ProtoUpdateNode::clear_updateindex() {
  if (GetArenaNoVirtual() == NULL && updateindex_ != NULL) {
    delete updateindex_;
  }
  updateindex_ = NULL;
}
inline const ::klee::ProtoExpr& ProtoUpdateNode::updateindex() const {
  const ::klee::ProtoExpr* p = updateindex_;
  // @@protoc_insertion_point(field_get:klee.ProtoUpdateNode.updateIndex)
  return p != NULL ? *p : *reinterpret_cast<const ::klee::ProtoExpr*>(
      &::klee::_ProtoExpr_default_instance_);
}
inline ::klee::ProtoExpr* ProtoUpdateNode::release_updateindex() {
  // @@protoc_insertion_point(field_release:klee.ProtoUpdateNode.updateIndex)
  
  ::klee::ProtoExpr* temp = updateindex_;
  updateindex_ = NULL;
  return temp;
}
inline ::klee::ProtoExpr* ProtoUpdateNode::mutable_updateindex() {
  
  if (updateindex_ == NULL) {
    updateindex_ = new ::klee::ProtoExpr;
  }
  // @@protoc_insertion_point(field_mutable:klee.ProtoUpdateNode.updateIndex)
  return updateindex_;
}
inline void ProtoUpdateNode::set_allocated_updateindex(::klee::ProtoExpr* updateindex) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete updateindex_;
  }
  if (updateindex) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      updateindex = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, updateindex, submessage_arena);
    }
    
  } else {
    
  }
  updateindex_ = updateindex;
  // @@protoc_insertion_point(field_set_allocated:klee.ProtoUpdateNode.updateIndex)
}

// .klee.ProtoExpr updateValue = 14;
inline bool ProtoUpdateNode::has_updatevalue() const {
  return this != internal_default_instance() && updatevalue_ != NULL;
}
inline void ProtoUpdateNode::clear_updatevalue() {
  if (GetArenaNoVirtual() == NULL && updatevalue_ != NULL) {
    delete updatevalue_;
  }
  updatevalue_ = NULL;
}
inline const ::klee::ProtoExpr& ProtoUpdateNode::updatevalue() const {
  const ::klee::ProtoExpr* p = updatevalue_;
  // @@protoc_insertion_point(field_get:klee.ProtoUpdateNode.updateValue)
  return p != NULL ? *p : *reinterpret_cast<const ::klee::ProtoExpr*>(
      &::klee::_ProtoExpr_default_instance_);
}
inline ::klee::ProtoExpr* ProtoUpdateNode::release_updatevalue() {
  // @@protoc_insertion_point(field_release:klee.ProtoUpdateNode.updateValue)
  
  ::klee::ProtoExpr* temp = updatevalue_;
  updatevalue_ = NULL;
  return temp;
}
inline ::klee::ProtoExpr* ProtoUpdateNode::mutable_updatevalue() {
  
  if (updatevalue_ == NULL) {
    updatevalue_ = new ::klee::ProtoExpr;
  }
  // @@protoc_insertion_point(field_mutable:klee.ProtoUpdateNode.updateValue)
  return updatevalue_;
}
inline void ProtoUpdateNode::set_allocated_updatevalue(::klee::ProtoExpr* updatevalue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete updatevalue_;
  }
  if (updatevalue) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      updatevalue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, updatevalue, submessage_arena);
    }
    
  } else {
    
  }
  updatevalue_ = updatevalue;
  // @@protoc_insertion_point(field_set_allocated:klee.ProtoUpdateNode.updateValue)
}

// .klee.ProtoUpdateNode next = 15;
inline bool ProtoUpdateNode::has_next() const {
  return this != internal_default_instance() && next_ != NULL;
}
inline void ProtoUpdateNode::clear_next() {
  if (GetArenaNoVirtual() == NULL && next_ != NULL) {
    delete next_;
  }
  next_ = NULL;
}
inline const ::klee::ProtoUpdateNode& ProtoUpdateNode::next() const {
  const ::klee::ProtoUpdateNode* p = next_;
  // @@protoc_insertion_point(field_get:klee.ProtoUpdateNode.next)
  return p != NULL ? *p : *reinterpret_cast<const ::klee::ProtoUpdateNode*>(
      &::klee::_ProtoUpdateNode_default_instance_);
}
inline ::klee::ProtoUpdateNode* ProtoUpdateNode::release_next() {
  // @@protoc_insertion_point(field_release:klee.ProtoUpdateNode.next)
  
  ::klee::ProtoUpdateNode* temp = next_;
  next_ = NULL;
  return temp;
}
inline ::klee::ProtoUpdateNode* ProtoUpdateNode::mutable_next() {
  
  if (next_ == NULL) {
    next_ = new ::klee::ProtoUpdateNode;
  }
  // @@protoc_insertion_point(field_mutable:klee.ProtoUpdateNode.next)
  return next_;
}
inline void ProtoUpdateNode::set_allocated_next(::klee::ProtoUpdateNode* next) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete next_;
  }
  if (next) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      next = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, next, submessage_arena);
    }
    
  } else {
    
  }
  next_ = next;
  // @@protoc_insertion_point(field_set_allocated:klee.ProtoUpdateNode.next)
}

// -------------------------------------------------------------------

// ProtoReadExpr

// .klee.ProtoUpdateNode head = 16;
inline bool ProtoReadExpr::has_head() const {
  return this != internal_default_instance() && head_ != NULL;
}
inline void ProtoReadExpr::clear_head() {
  if (GetArenaNoVirtual() == NULL && head_ != NULL) {
    delete head_;
  }
  head_ = NULL;
}
inline const ::klee::ProtoUpdateNode& ProtoReadExpr::head() const {
  const ::klee::ProtoUpdateNode* p = head_;
  // @@protoc_insertion_point(field_get:klee.ProtoReadExpr.head)
  return p != NULL ? *p : *reinterpret_cast<const ::klee::ProtoUpdateNode*>(
      &::klee::_ProtoUpdateNode_default_instance_);
}
inline ::klee::ProtoUpdateNode* ProtoReadExpr::release_head() {
  // @@protoc_insertion_point(field_release:klee.ProtoReadExpr.head)
  
  ::klee::ProtoUpdateNode* temp = head_;
  head_ = NULL;
  return temp;
}
inline ::klee::ProtoUpdateNode* ProtoReadExpr::mutable_head() {
  
  if (head_ == NULL) {
    head_ = new ::klee::ProtoUpdateNode;
  }
  // @@protoc_insertion_point(field_mutable:klee.ProtoReadExpr.head)
  return head_;
}
inline void ProtoReadExpr::set_allocated_head(::klee::ProtoUpdateNode* head) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete head_;
  }
  if (head) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      head = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  head_ = head;
  // @@protoc_insertion_point(field_set_allocated:klee.ProtoReadExpr.head)
}

// .klee.ProtoArray root = 17;
inline bool ProtoReadExpr::has_root() const {
  return this != internal_default_instance() && root_ != NULL;
}
inline void ProtoReadExpr::clear_root() {
  if (GetArenaNoVirtual() == NULL && root_ != NULL) {
    delete root_;
  }
  root_ = NULL;
}
inline const ::klee::ProtoArray& ProtoReadExpr::root() const {
  const ::klee::ProtoArray* p = root_;
  // @@protoc_insertion_point(field_get:klee.ProtoReadExpr.root)
  return p != NULL ? *p : *reinterpret_cast<const ::klee::ProtoArray*>(
      &::klee::_ProtoArray_default_instance_);
}
inline ::klee::ProtoArray* ProtoReadExpr::release_root() {
  // @@protoc_insertion_point(field_release:klee.ProtoReadExpr.root)
  
  ::klee::ProtoArray* temp = root_;
  root_ = NULL;
  return temp;
}
inline ::klee::ProtoArray* ProtoReadExpr::mutable_root() {
  
  if (root_ == NULL) {
    root_ = new ::klee::ProtoArray;
  }
  // @@protoc_insertion_point(field_mutable:klee.ProtoReadExpr.root)
  return root_;
}
inline void ProtoReadExpr::set_allocated_root(::klee::ProtoArray* root) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete root_;
  }
  if (root) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      root = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, root, submessage_arena);
    }
    
  } else {
    
  }
  root_ = root;
  // @@protoc_insertion_point(field_set_allocated:klee.ProtoReadExpr.root)
}

// .klee.ProtoExpr expr = 18;
inline bool ProtoReadExpr::has_expr() const {
  return this != internal_default_instance() && expr_ != NULL;
}
inline void ProtoReadExpr::clear_expr() {
  if (GetArenaNoVirtual() == NULL && expr_ != NULL) {
    delete expr_;
  }
  expr_ = NULL;
}
inline const ::klee::ProtoExpr& ProtoReadExpr::expr() const {
  const ::klee::ProtoExpr* p = expr_;
  // @@protoc_insertion_point(field_get:klee.ProtoReadExpr.expr)
  return p != NULL ? *p : *reinterpret_cast<const ::klee::ProtoExpr*>(
      &::klee::_ProtoExpr_default_instance_);
}
inline ::klee::ProtoExpr* ProtoReadExpr::release_expr() {
  // @@protoc_insertion_point(field_release:klee.ProtoReadExpr.expr)
  
  ::klee::ProtoExpr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline ::klee::ProtoExpr* ProtoReadExpr::mutable_expr() {
  
  if (expr_ == NULL) {
    expr_ = new ::klee::ProtoExpr;
  }
  // @@protoc_insertion_point(field_mutable:klee.ProtoReadExpr.expr)
  return expr_;
}
inline void ProtoReadExpr::set_allocated_expr(::klee::ProtoExpr* expr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete expr_;
  }
  if (expr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      expr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, expr, submessage_arena);
    }
    
  } else {
    
  }
  expr_ = expr;
  // @@protoc_insertion_point(field_set_allocated:klee.ProtoReadExpr.expr)
}

// -------------------------------------------------------------------

// ProtoExtractExpr

// uint32 extractBitOff = 19;
inline void ProtoExtractExpr::clear_extractbitoff() {
  extractbitoff_ = 0u;
}
inline ::google::protobuf::uint32 ProtoExtractExpr::extractbitoff() const {
  // @@protoc_insertion_point(field_get:klee.ProtoExtractExpr.extractBitOff)
  return extractbitoff_;
}
inline void ProtoExtractExpr::set_extractbitoff(::google::protobuf::uint32 value) {
  
  extractbitoff_ = value;
  // @@protoc_insertion_point(field_set:klee.ProtoExtractExpr.extractBitOff)
}

// uint32 extractWidth = 20;
inline void ProtoExtractExpr::clear_extractwidth() {
  extractwidth_ = 0u;
}
inline ::google::protobuf::uint32 ProtoExtractExpr::extractwidth() const {
  // @@protoc_insertion_point(field_get:klee.ProtoExtractExpr.extractWidth)
  return extractwidth_;
}
inline void ProtoExtractExpr::set_extractwidth(::google::protobuf::uint32 value) {
  
  extractwidth_ = value;
  // @@protoc_insertion_point(field_set:klee.ProtoExtractExpr.extractWidth)
}

// .klee.ProtoExpr expr = 21;
inline bool ProtoExtractExpr::has_expr() const {
  return this != internal_default_instance() && expr_ != NULL;
}
inline void ProtoExtractExpr::clear_expr() {
  if (GetArenaNoVirtual() == NULL && expr_ != NULL) {
    delete expr_;
  }
  expr_ = NULL;
}
inline const ::klee::ProtoExpr& ProtoExtractExpr::expr() const {
  const ::klee::ProtoExpr* p = expr_;
  // @@protoc_insertion_point(field_get:klee.ProtoExtractExpr.expr)
  return p != NULL ? *p : *reinterpret_cast<const ::klee::ProtoExpr*>(
      &::klee::_ProtoExpr_default_instance_);
}
inline ::klee::ProtoExpr* ProtoExtractExpr::release_expr() {
  // @@protoc_insertion_point(field_release:klee.ProtoExtractExpr.expr)
  
  ::klee::ProtoExpr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline ::klee::ProtoExpr* ProtoExtractExpr::mutable_expr() {
  
  if (expr_ == NULL) {
    expr_ = new ::klee::ProtoExpr;
  }
  // @@protoc_insertion_point(field_mutable:klee.ProtoExtractExpr.expr)
  return expr_;
}
inline void ProtoExtractExpr::set_allocated_expr(::klee::ProtoExpr* expr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete expr_;
  }
  if (expr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      expr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, expr, submessage_arena);
    }
    
  } else {
    
  }
  expr_ = expr;
  // @@protoc_insertion_point(field_set_allocated:klee.ProtoExtractExpr.expr)
}

// -------------------------------------------------------------------

// ProtoNotOptimizedExpr

// .klee.ProtoExpr src = 22;
inline bool ProtoNotOptimizedExpr::has_src() const {
  return this != internal_default_instance() && src_ != NULL;
}
inline void ProtoNotOptimizedExpr::clear_src() {
  if (GetArenaNoVirtual() == NULL && src_ != NULL) {
    delete src_;
  }
  src_ = NULL;
}
inline const ::klee::ProtoExpr& ProtoNotOptimizedExpr::src() const {
  const ::klee::ProtoExpr* p = src_;
  // @@protoc_insertion_point(field_get:klee.ProtoNotOptimizedExpr.src)
  return p != NULL ? *p : *reinterpret_cast<const ::klee::ProtoExpr*>(
      &::klee::_ProtoExpr_default_instance_);
}
inline ::klee::ProtoExpr* ProtoNotOptimizedExpr::release_src() {
  // @@protoc_insertion_point(field_release:klee.ProtoNotOptimizedExpr.src)
  
  ::klee::ProtoExpr* temp = src_;
  src_ = NULL;
  return temp;
}
inline ::klee::ProtoExpr* ProtoNotOptimizedExpr::mutable_src() {
  
  if (src_ == NULL) {
    src_ = new ::klee::ProtoExpr;
  }
  // @@protoc_insertion_point(field_mutable:klee.ProtoNotOptimizedExpr.src)
  return src_;
}
inline void ProtoNotOptimizedExpr::set_allocated_src(::klee::ProtoExpr* src) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete src_;
  }
  if (src) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      src = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, src, submessage_arena);
    }
    
  } else {
    
  }
  src_ = src;
  // @@protoc_insertion_point(field_set_allocated:klee.ProtoNotOptimizedExpr.src)
}

// -------------------------------------------------------------------

// Nothing

// -------------------------------------------------------------------

// ProtoExpr

// uint32 width = 23;
inline void ProtoExpr::clear_width() {
  width_ = 0u;
}
inline ::google::protobuf::uint32 ProtoExpr::width() const {
  // @@protoc_insertion_point(field_get:klee.ProtoExpr.width)
  return width_;
}
inline void ProtoExpr::set_width(::google::protobuf::uint32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:klee.ProtoExpr.width)
}

// uint32 kind = 24;
inline void ProtoExpr::clear_kind() {
  kind_ = 0u;
}
inline ::google::protobuf::uint32 ProtoExpr::kind() const {
  // @@protoc_insertion_point(field_get:klee.ProtoExpr.kind)
  return kind_;
}
inline void ProtoExpr::set_kind(::google::protobuf::uint32 value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:klee.ProtoExpr.kind)
}

// repeated .klee.ProtoExpr kids = 25;
inline int ProtoExpr::kids_size() const {
  return kids_.size();
}
inline void ProtoExpr::clear_kids() {
  kids_.Clear();
}
inline const ::klee::ProtoExpr& ProtoExpr::kids(int index) const {
  // @@protoc_insertion_point(field_get:klee.ProtoExpr.kids)
  return kids_.Get(index);
}
inline ::klee::ProtoExpr* ProtoExpr::mutable_kids(int index) {
  // @@protoc_insertion_point(field_mutable:klee.ProtoExpr.kids)
  return kids_.Mutable(index);
}
inline ::klee::ProtoExpr* ProtoExpr::add_kids() {
  // @@protoc_insertion_point(field_add:klee.ProtoExpr.kids)
  return kids_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr >*
ProtoExpr::mutable_kids() {
  // @@protoc_insertion_point(field_mutable_list:klee.ProtoExpr.kids)
  return &kids_;
}
inline const ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr >&
ProtoExpr::kids() const {
  // @@protoc_insertion_point(field_list:klee.ProtoExpr.kids)
  return kids_;
}

// .klee.ProtoConstExpr constData = 50;
inline bool ProtoExpr::has_constdata() const {
  return specialData_case() == kConstData;
}
inline void ProtoExpr::set_has_constdata() {
  _oneof_case_[0] = kConstData;
}
inline void ProtoExpr::clear_constdata() {
  if (has_constdata()) {
    delete specialData_.constdata_;
    clear_has_specialData();
  }
}
inline ::klee::ProtoConstExpr* ProtoExpr::release_constdata() {
  // @@protoc_insertion_point(field_release:klee.ProtoExpr.constData)
  if (has_constdata()) {
    clear_has_specialData();
      ::klee::ProtoConstExpr* temp = specialData_.constdata_;
    specialData_.constdata_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::klee::ProtoConstExpr& ProtoExpr::constdata() const {
  // @@protoc_insertion_point(field_get:klee.ProtoExpr.constData)
  return has_constdata()
      ? *specialData_.constdata_
      : *reinterpret_cast< ::klee::ProtoConstExpr*>(&::klee::_ProtoConstExpr_default_instance_);
}
inline ::klee::ProtoConstExpr* ProtoExpr::mutable_constdata() {
  if (!has_constdata()) {
    clear_specialData();
    set_has_constdata();
    specialData_.constdata_ = new ::klee::ProtoConstExpr;
  }
  // @@protoc_insertion_point(field_mutable:klee.ProtoExpr.constData)
  return specialData_.constdata_;
}

// .klee.ProtoReadExpr readData = 52;
inline bool ProtoExpr::has_readdata() const {
  return specialData_case() == kReadData;
}
inline void ProtoExpr::set_has_readdata() {
  _oneof_case_[0] = kReadData;
}
inline void ProtoExpr::clear_readdata() {
  if (has_readdata()) {
    delete specialData_.readdata_;
    clear_has_specialData();
  }
}
inline ::klee::ProtoReadExpr* ProtoExpr::release_readdata() {
  // @@protoc_insertion_point(field_release:klee.ProtoExpr.readData)
  if (has_readdata()) {
    clear_has_specialData();
      ::klee::ProtoReadExpr* temp = specialData_.readdata_;
    specialData_.readdata_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::klee::ProtoReadExpr& ProtoExpr::readdata() const {
  // @@protoc_insertion_point(field_get:klee.ProtoExpr.readData)
  return has_readdata()
      ? *specialData_.readdata_
      : *reinterpret_cast< ::klee::ProtoReadExpr*>(&::klee::_ProtoReadExpr_default_instance_);
}
inline ::klee::ProtoReadExpr* ProtoExpr::mutable_readdata() {
  if (!has_readdata()) {
    clear_specialData();
    set_has_readdata();
    specialData_.readdata_ = new ::klee::ProtoReadExpr;
  }
  // @@protoc_insertion_point(field_mutable:klee.ProtoExpr.readData)
  return specialData_.readdata_;
}

// .klee.ProtoExtractExpr extractData = 152;
inline bool ProtoExpr::has_extractdata() const {
  return specialData_case() == kExtractData;
}
inline void ProtoExpr::set_has_extractdata() {
  _oneof_case_[0] = kExtractData;
}
inline void ProtoExpr::clear_extractdata() {
  if (has_extractdata()) {
    delete specialData_.extractdata_;
    clear_has_specialData();
  }
}
inline ::klee::ProtoExtractExpr* ProtoExpr::release_extractdata() {
  // @@protoc_insertion_point(field_release:klee.ProtoExpr.extractData)
  if (has_extractdata()) {
    clear_has_specialData();
      ::klee::ProtoExtractExpr* temp = specialData_.extractdata_;
    specialData_.extractdata_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::klee::ProtoExtractExpr& ProtoExpr::extractdata() const {
  // @@protoc_insertion_point(field_get:klee.ProtoExpr.extractData)
  return has_extractdata()
      ? *specialData_.extractdata_
      : *reinterpret_cast< ::klee::ProtoExtractExpr*>(&::klee::_ProtoExtractExpr_default_instance_);
}
inline ::klee::ProtoExtractExpr* ProtoExpr::mutable_extractdata() {
  if (!has_extractdata()) {
    clear_specialData();
    set_has_extractdata();
    specialData_.extractdata_ = new ::klee::ProtoExtractExpr;
  }
  // @@protoc_insertion_point(field_mutable:klee.ProtoExpr.extractData)
  return specialData_.extractdata_;
}

// .klee.ProtoNotOptimizedExpr NOData = 153;
inline bool ProtoExpr::has_nodata() const {
  return specialData_case() == kNOData;
}
inline void ProtoExpr::set_has_nodata() {
  _oneof_case_[0] = kNOData;
}
inline void ProtoExpr::clear_nodata() {
  if (has_nodata()) {
    delete specialData_.nodata_;
    clear_has_specialData();
  }
}
inline ::klee::ProtoNotOptimizedExpr* ProtoExpr::release_nodata() {
  // @@protoc_insertion_point(field_release:klee.ProtoExpr.NOData)
  if (has_nodata()) {
    clear_has_specialData();
      ::klee::ProtoNotOptimizedExpr* temp = specialData_.nodata_;
    specialData_.nodata_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::klee::ProtoNotOptimizedExpr& ProtoExpr::nodata() const {
  // @@protoc_insertion_point(field_get:klee.ProtoExpr.NOData)
  return has_nodata()
      ? *specialData_.nodata_
      : *reinterpret_cast< ::klee::ProtoNotOptimizedExpr*>(&::klee::_ProtoNotOptimizedExpr_default_instance_);
}
inline ::klee::ProtoNotOptimizedExpr* ProtoExpr::mutable_nodata() {
  if (!has_nodata()) {
    clear_specialData();
    set_has_nodata();
    specialData_.nodata_ = new ::klee::ProtoNotOptimizedExpr;
  }
  // @@protoc_insertion_point(field_mutable:klee.ProtoExpr.NOData)
  return specialData_.nodata_;
}

// .klee.Nothing e = 155;
inline bool ProtoExpr::has_e() const {
  return specialData_case() == kE;
}
inline void ProtoExpr::set_has_e() {
  _oneof_case_[0] = kE;
}
inline void ProtoExpr::clear_e() {
  if (has_e()) {
    delete specialData_.e_;
    clear_has_specialData();
  }
}
inline ::klee::Nothing* ProtoExpr::release_e() {
  // @@protoc_insertion_point(field_release:klee.ProtoExpr.e)
  if (has_e()) {
    clear_has_specialData();
      ::klee::Nothing* temp = specialData_.e_;
    specialData_.e_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::klee::Nothing& ProtoExpr::e() const {
  // @@protoc_insertion_point(field_get:klee.ProtoExpr.e)
  return has_e()
      ? *specialData_.e_
      : *reinterpret_cast< ::klee::Nothing*>(&::klee::_Nothing_default_instance_);
}
inline ::klee::Nothing* ProtoExpr::mutable_e() {
  if (!has_e()) {
    clear_specialData();
    set_has_e();
    specialData_.e_ = new ::klee::Nothing;
  }
  // @@protoc_insertion_point(field_mutable:klee.ProtoExpr.e)
  return specialData_.e_;
}

inline bool ProtoExpr::has_specialData() const {
  return specialData_case() != SPECIALDATA_NOT_SET;
}
inline void ProtoExpr::clear_has_specialData() {
  _oneof_case_[0] = SPECIALDATA_NOT_SET;
}
inline ProtoExpr::SpecialDataCase ProtoExpr::specialData_case() const {
  return ProtoExpr::SpecialDataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ProtoCacheElem

// repeated .klee.ProtoExpr key = 156;
inline int ProtoCacheElem::key_size() const {
  return key_.size();
}
inline void ProtoCacheElem::clear_key() {
  key_.Clear();
}
inline const ::klee::ProtoExpr& ProtoCacheElem::key(int index) const {
  // @@protoc_insertion_point(field_get:klee.ProtoCacheElem.key)
  return key_.Get(index);
}
inline ::klee::ProtoExpr* ProtoCacheElem::mutable_key(int index) {
  // @@protoc_insertion_point(field_mutable:klee.ProtoCacheElem.key)
  return key_.Mutable(index);
}
inline ::klee::ProtoExpr* ProtoCacheElem::add_key() {
  // @@protoc_insertion_point(field_add:klee.ProtoCacheElem.key)
  return key_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr >*
ProtoCacheElem::mutable_key() {
  // @@protoc_insertion_point(field_mutable_list:klee.ProtoCacheElem.key)
  return &key_;
}
inline const ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr >&
ProtoCacheElem::key() const {
  // @@protoc_insertion_point(field_list:klee.ProtoCacheElem.key)
  return key_;
}

// .klee.ProtoAssignment assignment = 300;
inline bool ProtoCacheElem::has_assignment() const {
  return this != internal_default_instance() && assignment_ != NULL;
}
inline void ProtoCacheElem::clear_assignment() {
  if (GetArenaNoVirtual() == NULL && assignment_ != NULL) {
    delete assignment_;
  }
  assignment_ = NULL;
}
inline const ::klee::ProtoAssignment& ProtoCacheElem::assignment() const {
  const ::klee::ProtoAssignment* p = assignment_;
  // @@protoc_insertion_point(field_get:klee.ProtoCacheElem.assignment)
  return p != NULL ? *p : *reinterpret_cast<const ::klee::ProtoAssignment*>(
      &::klee::_ProtoAssignment_default_instance_);
}
inline ::klee::ProtoAssignment* ProtoCacheElem::release_assignment() {
  // @@protoc_insertion_point(field_release:klee.ProtoCacheElem.assignment)
  
  ::klee::ProtoAssignment* temp = assignment_;
  assignment_ = NULL;
  return temp;
}
inline ::klee::ProtoAssignment* ProtoCacheElem::mutable_assignment() {
  
  if (assignment_ == NULL) {
    assignment_ = new ::klee::ProtoAssignment;
  }
  // @@protoc_insertion_point(field_mutable:klee.ProtoCacheElem.assignment)
  return assignment_;
}
inline void ProtoCacheElem::set_allocated_assignment(::klee::ProtoAssignment* assignment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete assignment_;
  }
  if (assignment) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      assignment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, assignment, submessage_arena);
    }
    
  } else {
    
  }
  assignment_ = assignment;
  // @@protoc_insertion_point(field_set_allocated:klee.ProtoCacheElem.assignment)
}

// -------------------------------------------------------------------

// ProtoCache

// repeated .klee.ProtoCacheElem elem = 32;
inline int ProtoCache::elem_size() const {
  return elem_.size();
}
inline void ProtoCache::clear_elem() {
  elem_.Clear();
}
inline const ::klee::ProtoCacheElem& ProtoCache::elem(int index) const {
  // @@protoc_insertion_point(field_get:klee.ProtoCache.elem)
  return elem_.Get(index);
}
inline ::klee::ProtoCacheElem* ProtoCache::mutable_elem(int index) {
  // @@protoc_insertion_point(field_mutable:klee.ProtoCache.elem)
  return elem_.Mutable(index);
}
inline ::klee::ProtoCacheElem* ProtoCache::add_elem() {
  // @@protoc_insertion_point(field_add:klee.ProtoCache.elem)
  return elem_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::klee::ProtoCacheElem >*
ProtoCache::mutable_elem() {
  // @@protoc_insertion_point(field_mutable_list:klee.ProtoCache.elem)
  return &elem_;
}
inline const ::google::protobuf::RepeatedPtrField< ::klee::ProtoCacheElem >&
ProtoCache::elem() const {
  // @@protoc_insertion_point(field_list:klee.ProtoCache.elem)
  return elem_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace klee

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Cache_2eproto__INCLUDED
