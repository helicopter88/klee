// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Cache.proto

#ifndef PROTOBUF_Cache_2eproto__INCLUDED
#define PROTOBUF_Cache_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_Cache_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsProtoArrayImpl();
void InitDefaultsProtoArray();
void InitDefaultsProtoBitVectorImpl();
void InitDefaultsProtoBitVector();
void InitDefaultsProtoBindingImpl();
void InitDefaultsProtoBinding();
void InitDefaultsProtoAssignmentImpl();
void InitDefaultsProtoAssignment();
void InitDefaultsProtoExprImpl();
void InitDefaultsProtoExpr();
void InitDefaultsProtoCacheElemImpl();
void InitDefaultsProtoCacheElem();
void InitDefaultsProtoCacheImpl();
void InitDefaultsProtoCache();
inline void InitDefaults() {
  InitDefaultsProtoArray();
  InitDefaultsProtoBitVector();
  InitDefaultsProtoBinding();
  InitDefaultsProtoAssignment();
  InitDefaultsProtoExpr();
  InitDefaultsProtoCacheElem();
  InitDefaultsProtoCache();
}
}  // namespace protobuf_Cache_2eproto
namespace klee {
class ProtoArray;
class ProtoArrayDefaultTypeInternal;
extern ProtoArrayDefaultTypeInternal _ProtoArray_default_instance_;
class ProtoAssignment;
class ProtoAssignmentDefaultTypeInternal;
extern ProtoAssignmentDefaultTypeInternal _ProtoAssignment_default_instance_;
class ProtoBinding;
class ProtoBindingDefaultTypeInternal;
extern ProtoBindingDefaultTypeInternal _ProtoBinding_default_instance_;
class ProtoBitVector;
class ProtoBitVectorDefaultTypeInternal;
extern ProtoBitVectorDefaultTypeInternal _ProtoBitVector_default_instance_;
class ProtoCache;
class ProtoCacheDefaultTypeInternal;
extern ProtoCacheDefaultTypeInternal _ProtoCache_default_instance_;
class ProtoCacheElem;
class ProtoCacheElemDefaultTypeInternal;
extern ProtoCacheElemDefaultTypeInternal _ProtoCacheElem_default_instance_;
class ProtoExpr;
class ProtoExprDefaultTypeInternal;
extern ProtoExprDefaultTypeInternal _ProtoExpr_default_instance_;
}  // namespace klee
namespace klee {

// ===================================================================

class ProtoArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:klee.ProtoArray) */ {
 public:
  ProtoArray();
  virtual ~ProtoArray();

  ProtoArray(const ProtoArray& from);

  inline ProtoArray& operator=(const ProtoArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoArray(ProtoArray&& from) noexcept
    : ProtoArray() {
    *this = ::std::move(from);
  }

  inline ProtoArray& operator=(ProtoArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoArray& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoArray* internal_default_instance() {
    return reinterpret_cast<const ProtoArray*>(
               &_ProtoArray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ProtoArray* other);
  friend void swap(ProtoArray& a, ProtoArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoArray* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoArray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtoArray& from);
  void MergeFrom(const ProtoArray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtoArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // uint32 size = 2;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::uint32 size() const;
  void set_size(::google::protobuf::uint32 value);

  // uint32 domain = 3;
  void clear_domain();
  static const int kDomainFieldNumber = 3;
  ::google::protobuf::uint32 domain() const;
  void set_domain(::google::protobuf::uint32 value);

  // uint32 range = 4;
  void clear_range();
  static const int kRangeFieldNumber = 4;
  ::google::protobuf::uint32 range() const;
  void set_range(::google::protobuf::uint32 value);

  // uint32 hash = 5;
  void clear_hash();
  static const int kHashFieldNumber = 5;
  ::google::protobuf::uint32 hash() const;
  void set_hash(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:klee.ProtoArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 size_;
  ::google::protobuf::uint32 domain_;
  ::google::protobuf::uint32 range_;
  ::google::protobuf::uint32 hash_;
  mutable int _cached_size_;
  friend struct ::protobuf_Cache_2eproto::TableStruct;
  friend void ::protobuf_Cache_2eproto::InitDefaultsProtoArrayImpl();
};
// -------------------------------------------------------------------

class ProtoBitVector : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:klee.ProtoBitVector) */ {
 public:
  ProtoBitVector();
  virtual ~ProtoBitVector();

  ProtoBitVector(const ProtoBitVector& from);

  inline ProtoBitVector& operator=(const ProtoBitVector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoBitVector(ProtoBitVector&& from) noexcept
    : ProtoBitVector() {
    *this = ::std::move(from);
  }

  inline ProtoBitVector& operator=(ProtoBitVector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoBitVector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoBitVector* internal_default_instance() {
    return reinterpret_cast<const ProtoBitVector*>(
               &_ProtoBitVector_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ProtoBitVector* other);
  friend void swap(ProtoBitVector& a, ProtoBitVector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoBitVector* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoBitVector* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtoBitVector& from);
  void MergeFrom(const ProtoBitVector& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtoBitVector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::uint32 value(int index) const;
  void set_value(int index, ::google::protobuf::uint32 value);
  void add_value(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      value() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:klee.ProtoBitVector)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > value_;
  mutable int _value_cached_byte_size_;
  mutable int _cached_size_;
  friend struct ::protobuf_Cache_2eproto::TableStruct;
  friend void ::protobuf_Cache_2eproto::InitDefaultsProtoBitVectorImpl();
};
// -------------------------------------------------------------------

class ProtoBinding : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:klee.ProtoBinding) */ {
 public:
  ProtoBinding();
  virtual ~ProtoBinding();

  ProtoBinding(const ProtoBinding& from);

  inline ProtoBinding& operator=(const ProtoBinding& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoBinding(ProtoBinding&& from) noexcept
    : ProtoBinding() {
    *this = ::std::move(from);
  }

  inline ProtoBinding& operator=(ProtoBinding&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoBinding& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoBinding* internal_default_instance() {
    return reinterpret_cast<const ProtoBinding*>(
               &_ProtoBinding_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ProtoBinding* other);
  friend void swap(ProtoBinding& a, ProtoBinding& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoBinding* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoBinding* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtoBinding& from);
  void MergeFrom(const ProtoBinding& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtoBinding* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .klee.ProtoArray key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::klee::ProtoArray& key() const;
  ::klee::ProtoArray* release_key();
  ::klee::ProtoArray* mutable_key();
  void set_allocated_key(::klee::ProtoArray* key);

  // .klee.ProtoBitVector value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::klee::ProtoBitVector& value() const;
  ::klee::ProtoBitVector* release_value();
  ::klee::ProtoBitVector* mutable_value();
  void set_allocated_value(::klee::ProtoBitVector* value);

  // @@protoc_insertion_point(class_scope:klee.ProtoBinding)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::klee::ProtoArray* key_;
  ::klee::ProtoBitVector* value_;
  mutable int _cached_size_;
  friend struct ::protobuf_Cache_2eproto::TableStruct;
  friend void ::protobuf_Cache_2eproto::InitDefaultsProtoBindingImpl();
};
// -------------------------------------------------------------------

class ProtoAssignment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:klee.ProtoAssignment) */ {
 public:
  ProtoAssignment();
  virtual ~ProtoAssignment();

  ProtoAssignment(const ProtoAssignment& from);

  inline ProtoAssignment& operator=(const ProtoAssignment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoAssignment(ProtoAssignment&& from) noexcept
    : ProtoAssignment() {
    *this = ::std::move(from);
  }

  inline ProtoAssignment& operator=(ProtoAssignment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoAssignment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoAssignment* internal_default_instance() {
    return reinterpret_cast<const ProtoAssignment*>(
               &_ProtoAssignment_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ProtoAssignment* other);
  friend void swap(ProtoAssignment& a, ProtoAssignment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoAssignment* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoAssignment* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtoAssignment& from);
  void MergeFrom(const ProtoAssignment& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtoAssignment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .klee.ProtoBinding binding = 2;
  int binding_size() const;
  void clear_binding();
  static const int kBindingFieldNumber = 2;
  const ::klee::ProtoBinding& binding(int index) const;
  ::klee::ProtoBinding* mutable_binding(int index);
  ::klee::ProtoBinding* add_binding();
  ::google::protobuf::RepeatedPtrField< ::klee::ProtoBinding >*
      mutable_binding();
  const ::google::protobuf::RepeatedPtrField< ::klee::ProtoBinding >&
      binding() const;

  // bool allowFreeValues = 1;
  void clear_allowfreevalues();
  static const int kAllowFreeValuesFieldNumber = 1;
  bool allowfreevalues() const;
  void set_allowfreevalues(bool value);

  // @@protoc_insertion_point(class_scope:klee.ProtoAssignment)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::klee::ProtoBinding > binding_;
  bool allowfreevalues_;
  mutable int _cached_size_;
  friend struct ::protobuf_Cache_2eproto::TableStruct;
  friend void ::protobuf_Cache_2eproto::InitDefaultsProtoAssignmentImpl();
};
// -------------------------------------------------------------------

class ProtoExpr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:klee.ProtoExpr) */ {
 public:
  ProtoExpr();
  virtual ~ProtoExpr();

  ProtoExpr(const ProtoExpr& from);

  inline ProtoExpr& operator=(const ProtoExpr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoExpr(ProtoExpr&& from) noexcept
    : ProtoExpr() {
    *this = ::std::move(from);
  }

  inline ProtoExpr& operator=(ProtoExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoExpr* internal_default_instance() {
    return reinterpret_cast<const ProtoExpr*>(
               &_ProtoExpr_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ProtoExpr* other);
  friend void swap(ProtoExpr& a, ProtoExpr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoExpr* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoExpr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtoExpr& from);
  void MergeFrom(const ProtoExpr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtoExpr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .klee.ProtoExpr kids = 6;
  int kids_size() const;
  void clear_kids();
  static const int kKidsFieldNumber = 6;
  const ::klee::ProtoExpr& kids(int index) const;
  ::klee::ProtoExpr* mutable_kids(int index);
  ::klee::ProtoExpr* add_kids();
  ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr >*
      mutable_kids();
  const ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr >&
      kids() const;

  // uint32 width = 1;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // uint32 kind = 2;
  void clear_kind();
  static const int kKindFieldNumber = 2;
  ::google::protobuf::uint32 kind() const;
  void set_kind(::google::protobuf::uint32 value);

  // uint32 refCount = 3;
  void clear_refcount();
  static const int kRefCountFieldNumber = 3;
  ::google::protobuf::uint32 refcount() const;
  void set_refcount(::google::protobuf::uint32 value);

  // uint32 hash = 4;
  void clear_hash();
  static const int kHashFieldNumber = 4;
  ::google::protobuf::uint32 hash() const;
  void set_hash(::google::protobuf::uint32 value);

  // uint32 numKids = 5;
  void clear_numkids();
  static const int kNumKidsFieldNumber = 5;
  ::google::protobuf::uint32 numkids() const;
  void set_numkids(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:klee.ProtoExpr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr > kids_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 kind_;
  ::google::protobuf::uint32 refcount_;
  ::google::protobuf::uint32 hash_;
  ::google::protobuf::uint32 numkids_;
  mutable int _cached_size_;
  friend struct ::protobuf_Cache_2eproto::TableStruct;
  friend void ::protobuf_Cache_2eproto::InitDefaultsProtoExprImpl();
};
// -------------------------------------------------------------------

class ProtoCacheElem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:klee.ProtoCacheElem) */ {
 public:
  ProtoCacheElem();
  virtual ~ProtoCacheElem();

  ProtoCacheElem(const ProtoCacheElem& from);

  inline ProtoCacheElem& operator=(const ProtoCacheElem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoCacheElem(ProtoCacheElem&& from) noexcept
    : ProtoCacheElem() {
    *this = ::std::move(from);
  }

  inline ProtoCacheElem& operator=(ProtoCacheElem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoCacheElem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoCacheElem* internal_default_instance() {
    return reinterpret_cast<const ProtoCacheElem*>(
               &_ProtoCacheElem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ProtoCacheElem* other);
  friend void swap(ProtoCacheElem& a, ProtoCacheElem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoCacheElem* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoCacheElem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtoCacheElem& from);
  void MergeFrom(const ProtoCacheElem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtoCacheElem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .klee.ProtoExpr key = 1;
  int key_size() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::klee::ProtoExpr& key(int index) const;
  ::klee::ProtoExpr* mutable_key(int index);
  ::klee::ProtoExpr* add_key();
  ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr >*
      mutable_key();
  const ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr >&
      key() const;

  // .klee.ProtoAssignment assignment = 2;
  bool has_assignment() const;
  void clear_assignment();
  static const int kAssignmentFieldNumber = 2;
  const ::klee::ProtoAssignment& assignment() const;
  ::klee::ProtoAssignment* release_assignment();
  ::klee::ProtoAssignment* mutable_assignment();
  void set_allocated_assignment(::klee::ProtoAssignment* assignment);

  // @@protoc_insertion_point(class_scope:klee.ProtoCacheElem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr > key_;
  ::klee::ProtoAssignment* assignment_;
  mutable int _cached_size_;
  friend struct ::protobuf_Cache_2eproto::TableStruct;
  friend void ::protobuf_Cache_2eproto::InitDefaultsProtoCacheElemImpl();
};
// -------------------------------------------------------------------

class ProtoCache : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:klee.ProtoCache) */ {
 public:
  ProtoCache();
  virtual ~ProtoCache();

  ProtoCache(const ProtoCache& from);

  inline ProtoCache& operator=(const ProtoCache& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoCache(ProtoCache&& from) noexcept
    : ProtoCache() {
    *this = ::std::move(from);
  }

  inline ProtoCache& operator=(ProtoCache&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoCache& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoCache* internal_default_instance() {
    return reinterpret_cast<const ProtoCache*>(
               &_ProtoCache_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ProtoCache* other);
  friend void swap(ProtoCache& a, ProtoCache& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoCache* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoCache* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtoCache& from);
  void MergeFrom(const ProtoCache& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtoCache* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .klee.ProtoCacheElem elem = 1;
  int elem_size() const;
  void clear_elem();
  static const int kElemFieldNumber = 1;
  const ::klee::ProtoCacheElem& elem(int index) const;
  ::klee::ProtoCacheElem* mutable_elem(int index);
  ::klee::ProtoCacheElem* add_elem();
  ::google::protobuf::RepeatedPtrField< ::klee::ProtoCacheElem >*
      mutable_elem();
  const ::google::protobuf::RepeatedPtrField< ::klee::ProtoCacheElem >&
      elem() const;

  // @@protoc_insertion_point(class_scope:klee.ProtoCache)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::klee::ProtoCacheElem > elem_;
  mutable int _cached_size_;
  friend struct ::protobuf_Cache_2eproto::TableStruct;
  friend void ::protobuf_Cache_2eproto::InitDefaultsProtoCacheImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ProtoArray

// string name = 1;
inline void ProtoArray::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProtoArray::name() const {
  // @@protoc_insertion_point(field_get:klee.ProtoArray.name)
  return name_.GetNoArena();
}
inline void ProtoArray::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:klee.ProtoArray.name)
}
#if LANG_CXX11
inline void ProtoArray::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:klee.ProtoArray.name)
}
#endif
inline void ProtoArray::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:klee.ProtoArray.name)
}
inline void ProtoArray::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:klee.ProtoArray.name)
}
inline ::std::string* ProtoArray::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:klee.ProtoArray.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoArray::release_name() {
  // @@protoc_insertion_point(field_release:klee.ProtoArray.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoArray::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:klee.ProtoArray.name)
}

// uint32 size = 2;
inline void ProtoArray::clear_size() {
  size_ = 0u;
}
inline ::google::protobuf::uint32 ProtoArray::size() const {
  // @@protoc_insertion_point(field_get:klee.ProtoArray.size)
  return size_;
}
inline void ProtoArray::set_size(::google::protobuf::uint32 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:klee.ProtoArray.size)
}

// uint32 domain = 3;
inline void ProtoArray::clear_domain() {
  domain_ = 0u;
}
inline ::google::protobuf::uint32 ProtoArray::domain() const {
  // @@protoc_insertion_point(field_get:klee.ProtoArray.domain)
  return domain_;
}
inline void ProtoArray::set_domain(::google::protobuf::uint32 value) {
  
  domain_ = value;
  // @@protoc_insertion_point(field_set:klee.ProtoArray.domain)
}

// uint32 range = 4;
inline void ProtoArray::clear_range() {
  range_ = 0u;
}
inline ::google::protobuf::uint32 ProtoArray::range() const {
  // @@protoc_insertion_point(field_get:klee.ProtoArray.range)
  return range_;
}
inline void ProtoArray::set_range(::google::protobuf::uint32 value) {
  
  range_ = value;
  // @@protoc_insertion_point(field_set:klee.ProtoArray.range)
}

// uint32 hash = 5;
inline void ProtoArray::clear_hash() {
  hash_ = 0u;
}
inline ::google::protobuf::uint32 ProtoArray::hash() const {
  // @@protoc_insertion_point(field_get:klee.ProtoArray.hash)
  return hash_;
}
inline void ProtoArray::set_hash(::google::protobuf::uint32 value) {
  
  hash_ = value;
  // @@protoc_insertion_point(field_set:klee.ProtoArray.hash)
}

// -------------------------------------------------------------------

// ProtoBitVector

// repeated uint32 value = 1;
inline int ProtoBitVector::value_size() const {
  return value_.size();
}
inline void ProtoBitVector::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::uint32 ProtoBitVector::value(int index) const {
  // @@protoc_insertion_point(field_get:klee.ProtoBitVector.value)
  return value_.Get(index);
}
inline void ProtoBitVector::set_value(int index, ::google::protobuf::uint32 value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:klee.ProtoBitVector.value)
}
inline void ProtoBitVector::add_value(::google::protobuf::uint32 value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:klee.ProtoBitVector.value)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ProtoBitVector::value() const {
  // @@protoc_insertion_point(field_list:klee.ProtoBitVector.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ProtoBitVector::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:klee.ProtoBitVector.value)
  return &value_;
}

// -------------------------------------------------------------------

// ProtoBinding

// .klee.ProtoArray key = 1;
inline bool ProtoBinding::has_key() const {
  return this != internal_default_instance() && key_ != NULL;
}
inline void ProtoBinding::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) {
    delete key_;
  }
  key_ = NULL;
}
inline const ::klee::ProtoArray& ProtoBinding::key() const {
  const ::klee::ProtoArray* p = key_;
  // @@protoc_insertion_point(field_get:klee.ProtoBinding.key)
  return p != NULL ? *p : *reinterpret_cast<const ::klee::ProtoArray*>(
      &::klee::_ProtoArray_default_instance_);
}
inline ::klee::ProtoArray* ProtoBinding::release_key() {
  // @@protoc_insertion_point(field_release:klee.ProtoBinding.key)
  
  ::klee::ProtoArray* temp = key_;
  key_ = NULL;
  return temp;
}
inline ::klee::ProtoArray* ProtoBinding::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::klee::ProtoArray;
  }
  // @@protoc_insertion_point(field_mutable:klee.ProtoBinding.key)
  return key_;
}
inline void ProtoBinding::set_allocated_key(::klee::ProtoArray* key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete key_;
  }
  if (key) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:klee.ProtoBinding.key)
}

// .klee.ProtoBitVector value = 2;
inline bool ProtoBinding::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void ProtoBinding::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) {
    delete value_;
  }
  value_ = NULL;
}
inline const ::klee::ProtoBitVector& ProtoBinding::value() const {
  const ::klee::ProtoBitVector* p = value_;
  // @@protoc_insertion_point(field_get:klee.ProtoBinding.value)
  return p != NULL ? *p : *reinterpret_cast<const ::klee::ProtoBitVector*>(
      &::klee::_ProtoBitVector_default_instance_);
}
inline ::klee::ProtoBitVector* ProtoBinding::release_value() {
  // @@protoc_insertion_point(field_release:klee.ProtoBinding.value)
  
  ::klee::ProtoBitVector* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::klee::ProtoBitVector* ProtoBinding::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::klee::ProtoBitVector;
  }
  // @@protoc_insertion_point(field_mutable:klee.ProtoBinding.value)
  return value_;
}
inline void ProtoBinding::set_allocated_value(::klee::ProtoBitVector* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:klee.ProtoBinding.value)
}

// -------------------------------------------------------------------

// ProtoAssignment

// bool allowFreeValues = 1;
inline void ProtoAssignment::clear_allowfreevalues() {
  allowfreevalues_ = false;
}
inline bool ProtoAssignment::allowfreevalues() const {
  // @@protoc_insertion_point(field_get:klee.ProtoAssignment.allowFreeValues)
  return allowfreevalues_;
}
inline void ProtoAssignment::set_allowfreevalues(bool value) {
  
  allowfreevalues_ = value;
  // @@protoc_insertion_point(field_set:klee.ProtoAssignment.allowFreeValues)
}

// repeated .klee.ProtoBinding binding = 2;
inline int ProtoAssignment::binding_size() const {
  return binding_.size();
}
inline void ProtoAssignment::clear_binding() {
  binding_.Clear();
}
inline const ::klee::ProtoBinding& ProtoAssignment::binding(int index) const {
  // @@protoc_insertion_point(field_get:klee.ProtoAssignment.binding)
  return binding_.Get(index);
}
inline ::klee::ProtoBinding* ProtoAssignment::mutable_binding(int index) {
  // @@protoc_insertion_point(field_mutable:klee.ProtoAssignment.binding)
  return binding_.Mutable(index);
}
inline ::klee::ProtoBinding* ProtoAssignment::add_binding() {
  // @@protoc_insertion_point(field_add:klee.ProtoAssignment.binding)
  return binding_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::klee::ProtoBinding >*
ProtoAssignment::mutable_binding() {
  // @@protoc_insertion_point(field_mutable_list:klee.ProtoAssignment.binding)
  return &binding_;
}
inline const ::google::protobuf::RepeatedPtrField< ::klee::ProtoBinding >&
ProtoAssignment::binding() const {
  // @@protoc_insertion_point(field_list:klee.ProtoAssignment.binding)
  return binding_;
}

// -------------------------------------------------------------------

// ProtoExpr

// uint32 width = 1;
inline void ProtoExpr::clear_width() {
  width_ = 0u;
}
inline ::google::protobuf::uint32 ProtoExpr::width() const {
  // @@protoc_insertion_point(field_get:klee.ProtoExpr.width)
  return width_;
}
inline void ProtoExpr::set_width(::google::protobuf::uint32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:klee.ProtoExpr.width)
}

// uint32 kind = 2;
inline void ProtoExpr::clear_kind() {
  kind_ = 0u;
}
inline ::google::protobuf::uint32 ProtoExpr::kind() const {
  // @@protoc_insertion_point(field_get:klee.ProtoExpr.kind)
  return kind_;
}
inline void ProtoExpr::set_kind(::google::protobuf::uint32 value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:klee.ProtoExpr.kind)
}

// uint32 refCount = 3;
inline void ProtoExpr::clear_refcount() {
  refcount_ = 0u;
}
inline ::google::protobuf::uint32 ProtoExpr::refcount() const {
  // @@protoc_insertion_point(field_get:klee.ProtoExpr.refCount)
  return refcount_;
}
inline void ProtoExpr::set_refcount(::google::protobuf::uint32 value) {
  
  refcount_ = value;
  // @@protoc_insertion_point(field_set:klee.ProtoExpr.refCount)
}

// uint32 hash = 4;
inline void ProtoExpr::clear_hash() {
  hash_ = 0u;
}
inline ::google::protobuf::uint32 ProtoExpr::hash() const {
  // @@protoc_insertion_point(field_get:klee.ProtoExpr.hash)
  return hash_;
}
inline void ProtoExpr::set_hash(::google::protobuf::uint32 value) {
  
  hash_ = value;
  // @@protoc_insertion_point(field_set:klee.ProtoExpr.hash)
}

// uint32 numKids = 5;
inline void ProtoExpr::clear_numkids() {
  numkids_ = 0u;
}
inline ::google::protobuf::uint32 ProtoExpr::numkids() const {
  // @@protoc_insertion_point(field_get:klee.ProtoExpr.numKids)
  return numkids_;
}
inline void ProtoExpr::set_numkids(::google::protobuf::uint32 value) {
  
  numkids_ = value;
  // @@protoc_insertion_point(field_set:klee.ProtoExpr.numKids)
}

// repeated .klee.ProtoExpr kids = 6;
inline int ProtoExpr::kids_size() const {
  return kids_.size();
}
inline void ProtoExpr::clear_kids() {
  kids_.Clear();
}
inline const ::klee::ProtoExpr& ProtoExpr::kids(int index) const {
  // @@protoc_insertion_point(field_get:klee.ProtoExpr.kids)
  return kids_.Get(index);
}
inline ::klee::ProtoExpr* ProtoExpr::mutable_kids(int index) {
  // @@protoc_insertion_point(field_mutable:klee.ProtoExpr.kids)
  return kids_.Mutable(index);
}
inline ::klee::ProtoExpr* ProtoExpr::add_kids() {
  // @@protoc_insertion_point(field_add:klee.ProtoExpr.kids)
  return kids_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr >*
ProtoExpr::mutable_kids() {
  // @@protoc_insertion_point(field_mutable_list:klee.ProtoExpr.kids)
  return &kids_;
}
inline const ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr >&
ProtoExpr::kids() const {
  // @@protoc_insertion_point(field_list:klee.ProtoExpr.kids)
  return kids_;
}

// -------------------------------------------------------------------

// ProtoCacheElem

// repeated .klee.ProtoExpr key = 1;
inline int ProtoCacheElem::key_size() const {
  return key_.size();
}
inline void ProtoCacheElem::clear_key() {
  key_.Clear();
}
inline const ::klee::ProtoExpr& ProtoCacheElem::key(int index) const {
  // @@protoc_insertion_point(field_get:klee.ProtoCacheElem.key)
  return key_.Get(index);
}
inline ::klee::ProtoExpr* ProtoCacheElem::mutable_key(int index) {
  // @@protoc_insertion_point(field_mutable:klee.ProtoCacheElem.key)
  return key_.Mutable(index);
}
inline ::klee::ProtoExpr* ProtoCacheElem::add_key() {
  // @@protoc_insertion_point(field_add:klee.ProtoCacheElem.key)
  return key_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr >*
ProtoCacheElem::mutable_key() {
  // @@protoc_insertion_point(field_mutable_list:klee.ProtoCacheElem.key)
  return &key_;
}
inline const ::google::protobuf::RepeatedPtrField< ::klee::ProtoExpr >&
ProtoCacheElem::key() const {
  // @@protoc_insertion_point(field_list:klee.ProtoCacheElem.key)
  return key_;
}

// .klee.ProtoAssignment assignment = 2;
inline bool ProtoCacheElem::has_assignment() const {
  return this != internal_default_instance() && assignment_ != NULL;
}
inline void ProtoCacheElem::clear_assignment() {
  if (GetArenaNoVirtual() == NULL && assignment_ != NULL) {
    delete assignment_;
  }
  assignment_ = NULL;
}
inline const ::klee::ProtoAssignment& ProtoCacheElem::assignment() const {
  const ::klee::ProtoAssignment* p = assignment_;
  // @@protoc_insertion_point(field_get:klee.ProtoCacheElem.assignment)
  return p != NULL ? *p : *reinterpret_cast<const ::klee::ProtoAssignment*>(
      &::klee::_ProtoAssignment_default_instance_);
}
inline ::klee::ProtoAssignment* ProtoCacheElem::release_assignment() {
  // @@protoc_insertion_point(field_release:klee.ProtoCacheElem.assignment)
  
  ::klee::ProtoAssignment* temp = assignment_;
  assignment_ = NULL;
  return temp;
}
inline ::klee::ProtoAssignment* ProtoCacheElem::mutable_assignment() {
  
  if (assignment_ == NULL) {
    assignment_ = new ::klee::ProtoAssignment;
  }
  // @@protoc_insertion_point(field_mutable:klee.ProtoCacheElem.assignment)
  return assignment_;
}
inline void ProtoCacheElem::set_allocated_assignment(::klee::ProtoAssignment* assignment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete assignment_;
  }
  if (assignment) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      assignment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, assignment, submessage_arena);
    }
    
  } else {
    
  }
  assignment_ = assignment;
  // @@protoc_insertion_point(field_set_allocated:klee.ProtoCacheElem.assignment)
}

// -------------------------------------------------------------------

// ProtoCache

// repeated .klee.ProtoCacheElem elem = 1;
inline int ProtoCache::elem_size() const {
  return elem_.size();
}
inline void ProtoCache::clear_elem() {
  elem_.Clear();
}
inline const ::klee::ProtoCacheElem& ProtoCache::elem(int index) const {
  // @@protoc_insertion_point(field_get:klee.ProtoCache.elem)
  return elem_.Get(index);
}
inline ::klee::ProtoCacheElem* ProtoCache::mutable_elem(int index) {
  // @@protoc_insertion_point(field_mutable:klee.ProtoCache.elem)
  return elem_.Mutable(index);
}
inline ::klee::ProtoCacheElem* ProtoCache::add_elem() {
  // @@protoc_insertion_point(field_add:klee.ProtoCache.elem)
  return elem_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::klee::ProtoCacheElem >*
ProtoCache::mutable_elem() {
  // @@protoc_insertion_point(field_mutable_list:klee.ProtoCache.elem)
  return &elem_;
}
inline const ::google::protobuf::RepeatedPtrField< ::klee::ProtoCacheElem >&
ProtoCache::elem() const {
  // @@protoc_insertion_point(field_list:klee.ProtoCache.elem)
  return elem_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace klee

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Cache_2eproto__INCLUDED
