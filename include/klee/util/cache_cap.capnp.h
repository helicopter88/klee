// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: cache_cap.capnp

#ifndef CAPNP_INCLUDED_c8927f547a124ed2_
#define CAPNP_INCLUDED_c8927f547a124ed2_

#include <capnp/generated-header-support.h>

#if CAPNP_VERSION != 6001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(fd051794d4a7c0df);
CAPNP_DECLARE_SCHEMA(ba91a8b28f79147e);
CAPNP_DECLARE_SCHEMA(98f930e8a694b853);
CAPNP_DECLARE_SCHEMA(936102c2f7c6f80a);
CAPNP_DECLARE_SCHEMA(a9f06afb20219826);
CAPNP_DECLARE_SCHEMA(bea86a9f77558818);
CAPNP_DECLARE_SCHEMA(94aa3ba4821d3c44);
CAPNP_DECLARE_SCHEMA(c9c672bd150bfcea);
CAPNP_DECLARE_SCHEMA(aff84ea39857badf);
CAPNP_DECLARE_SCHEMA(c10955f42d02090c);
CAPNP_DECLARE_SCHEMA(bea231dc3c8767bf);
CAPNP_DECLARE_SCHEMA(dd31e84586c9a967);
CAPNP_DECLARE_SCHEMA(9bf4190d43974873);

}  // namespace schemas
}  // namespace capnp


struct CacheArray {
  CacheArray() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fd051794d4a7c0df, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CacheAssignment {
  CacheAssignment() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Binding;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ba91a8b28f79147e, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CacheAssignment::Binding {
  Binding() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(98f930e8a694b853, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CacheConstExpr {
  CacheConstExpr() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(936102c2f7c6f80a, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CacheExtractExpr {
  CacheExtractExpr() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a9f06afb20219826, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CacheNotOptimisedExpr {
  CacheNotOptimisedExpr() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bea86a9f77558818, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CacheUpdateNode {
  CacheUpdateNode() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(94aa3ba4821d3c44, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CacheReadExpr {
  CacheReadExpr() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c9c672bd150bfcea, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CacheExpr {
  CacheExpr() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct SpecialData;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(aff84ea39857badf, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CacheExpr::SpecialData {
  SpecialData() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    NOTHING,
    CONST_DATA,
    READ_DATA,
    EXTRACT_DATA,
    N_O_DATA,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c10955f42d02090c, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CacheExprList {
  CacheExprList() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bea231dc3c8767bf, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CapCache {
  CapCache() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Elem;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dd31e84586c9a967, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CapCache::Elem {
  Elem() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9bf4190d43974873, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class CacheArray::Reader {
public:
  typedef CacheArray Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline  ::uint64_t getSize() const;

  inline  ::uint32_t getDomain() const;

  inline  ::uint32_t getRange() const;

  inline bool hasConstantValues() const;
  inline  ::capnp::List< ::CacheExpr>::Reader getConstantValues() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CacheArray::Builder {
public:
  typedef CacheArray Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline  ::uint64_t getSize();
  inline void setSize( ::uint64_t value);

  inline  ::uint32_t getDomain();
  inline void setDomain( ::uint32_t value);

  inline  ::uint32_t getRange();
  inline void setRange( ::uint32_t value);

  inline bool hasConstantValues();
  inline  ::capnp::List< ::CacheExpr>::Builder getConstantValues();
  inline void setConstantValues( ::capnp::List< ::CacheExpr>::Reader value);
  inline  ::capnp::List< ::CacheExpr>::Builder initConstantValues(unsigned int size);
  inline void adoptConstantValues(::capnp::Orphan< ::capnp::List< ::CacheExpr>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::CacheExpr>> disownConstantValues();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CacheArray::Pipeline {
public:
  typedef CacheArray Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CacheAssignment::Reader {
public:
  typedef CacheAssignment Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getAllowFreeValues() const;

  inline bool hasBindings() const;
  inline  ::capnp::List< ::CacheAssignment::Binding>::Reader getBindings() const;

  inline bool getNoBinding() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CacheAssignment::Builder {
public:
  typedef CacheAssignment Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getAllowFreeValues();
  inline void setAllowFreeValues(bool value);

  inline bool hasBindings();
  inline  ::capnp::List< ::CacheAssignment::Binding>::Builder getBindings();
  inline void setBindings( ::capnp::List< ::CacheAssignment::Binding>::Reader value);
  inline  ::capnp::List< ::CacheAssignment::Binding>::Builder initBindings(unsigned int size);
  inline void adoptBindings(::capnp::Orphan< ::capnp::List< ::CacheAssignment::Binding>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::CacheAssignment::Binding>> disownBindings();

  inline bool getNoBinding();
  inline void setNoBinding(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CacheAssignment::Pipeline {
public:
  typedef CacheAssignment Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CacheAssignment::Binding::Reader {
public:
  typedef Binding Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasObjects() const;
  inline  ::CacheArray::Reader getObjects() const;

  inline bool hasBvs() const;
  inline  ::capnp::List< ::uint8_t>::Reader getBvs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CacheAssignment::Binding::Builder {
public:
  typedef Binding Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasObjects();
  inline  ::CacheArray::Builder getObjects();
  inline void setObjects( ::CacheArray::Reader value);
  inline  ::CacheArray::Builder initObjects();
  inline void adoptObjects(::capnp::Orphan< ::CacheArray>&& value);
  inline ::capnp::Orphan< ::CacheArray> disownObjects();

  inline bool hasBvs();
  inline  ::capnp::List< ::uint8_t>::Builder getBvs();
  inline void setBvs( ::capnp::List< ::uint8_t>::Reader value);
  inline void setBvs(::kj::ArrayPtr<const  ::uint8_t> value);
  inline  ::capnp::List< ::uint8_t>::Builder initBvs(unsigned int size);
  inline void adoptBvs(::capnp::Orphan< ::capnp::List< ::uint8_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint8_t>> disownBvs();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CacheAssignment::Binding::Pipeline {
public:
  typedef Binding Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::CacheArray::Pipeline getObjects();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CacheConstExpr::Reader {
public:
  typedef CacheConstExpr Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getConstExprWidth() const;

  inline  ::uint64_t getConstExprVal() const;

  inline bool hasConstExprOverSizeVal() const;
  inline  ::capnp::Text::Reader getConstExprOverSizeVal() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CacheConstExpr::Builder {
public:
  typedef CacheConstExpr Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getConstExprWidth();
  inline void setConstExprWidth( ::uint32_t value);

  inline  ::uint64_t getConstExprVal();
  inline void setConstExprVal( ::uint64_t value);

  inline bool hasConstExprOverSizeVal();
  inline  ::capnp::Text::Builder getConstExprOverSizeVal();
  inline void setConstExprOverSizeVal( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initConstExprOverSizeVal(unsigned int size);
  inline void adoptConstExprOverSizeVal(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownConstExprOverSizeVal();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CacheConstExpr::Pipeline {
public:
  typedef CacheConstExpr Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CacheExtractExpr::Reader {
public:
  typedef CacheExtractExpr Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getExtractBitOff() const;

  inline  ::uint32_t getExtractWidth() const;

  inline bool hasExpr() const;
  inline  ::CacheExpr::Reader getExpr() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CacheExtractExpr::Builder {
public:
  typedef CacheExtractExpr Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getExtractBitOff();
  inline void setExtractBitOff( ::uint32_t value);

  inline  ::uint32_t getExtractWidth();
  inline void setExtractWidth( ::uint32_t value);

  inline bool hasExpr();
  inline  ::CacheExpr::Builder getExpr();
  inline void setExpr( ::CacheExpr::Reader value);
  inline  ::CacheExpr::Builder initExpr();
  inline void adoptExpr(::capnp::Orphan< ::CacheExpr>&& value);
  inline ::capnp::Orphan< ::CacheExpr> disownExpr();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CacheExtractExpr::Pipeline {
public:
  typedef CacheExtractExpr Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::CacheExpr::Pipeline getExpr();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CacheNotOptimisedExpr::Reader {
public:
  typedef CacheNotOptimisedExpr Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSrc() const;
  inline  ::CacheExpr::Reader getSrc() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CacheNotOptimisedExpr::Builder {
public:
  typedef CacheNotOptimisedExpr Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSrc();
  inline  ::CacheExpr::Builder getSrc();
  inline void setSrc( ::CacheExpr::Reader value);
  inline  ::CacheExpr::Builder initSrc();
  inline void adoptSrc(::capnp::Orphan< ::CacheExpr>&& value);
  inline ::capnp::Orphan< ::CacheExpr> disownSrc();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CacheNotOptimisedExpr::Pipeline {
public:
  typedef CacheNotOptimisedExpr Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::CacheExpr::Pipeline getSrc();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CacheUpdateNode::Reader {
public:
  typedef CacheUpdateNode Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasUpdateIndex() const;
  inline  ::CacheExpr::Reader getUpdateIndex() const;

  inline bool hasUpdateValue() const;
  inline  ::CacheExpr::Reader getUpdateValue() const;

  inline bool hasNext() const;
  inline  ::CacheUpdateNode::Reader getNext() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CacheUpdateNode::Builder {
public:
  typedef CacheUpdateNode Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasUpdateIndex();
  inline  ::CacheExpr::Builder getUpdateIndex();
  inline void setUpdateIndex( ::CacheExpr::Reader value);
  inline  ::CacheExpr::Builder initUpdateIndex();
  inline void adoptUpdateIndex(::capnp::Orphan< ::CacheExpr>&& value);
  inline ::capnp::Orphan< ::CacheExpr> disownUpdateIndex();

  inline bool hasUpdateValue();
  inline  ::CacheExpr::Builder getUpdateValue();
  inline void setUpdateValue( ::CacheExpr::Reader value);
  inline  ::CacheExpr::Builder initUpdateValue();
  inline void adoptUpdateValue(::capnp::Orphan< ::CacheExpr>&& value);
  inline ::capnp::Orphan< ::CacheExpr> disownUpdateValue();

  inline bool hasNext();
  inline  ::CacheUpdateNode::Builder getNext();
  inline void setNext( ::CacheUpdateNode::Reader value);
  inline  ::CacheUpdateNode::Builder initNext();
  inline void adoptNext(::capnp::Orphan< ::CacheUpdateNode>&& value);
  inline ::capnp::Orphan< ::CacheUpdateNode> disownNext();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CacheUpdateNode::Pipeline {
public:
  typedef CacheUpdateNode Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::CacheExpr::Pipeline getUpdateIndex();
  inline  ::CacheExpr::Pipeline getUpdateValue();
  inline  ::CacheUpdateNode::Pipeline getNext();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CacheReadExpr::Reader {
public:
  typedef CacheReadExpr Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasRoot() const;
  inline  ::CacheArray::Reader getRoot() const;

  inline bool hasExpr() const;
  inline  ::CacheExpr::Reader getExpr() const;

  inline bool hasHead() const;
  inline  ::CacheUpdateNode::Reader getHead() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CacheReadExpr::Builder {
public:
  typedef CacheReadExpr Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasRoot();
  inline  ::CacheArray::Builder getRoot();
  inline void setRoot( ::CacheArray::Reader value);
  inline  ::CacheArray::Builder initRoot();
  inline void adoptRoot(::capnp::Orphan< ::CacheArray>&& value);
  inline ::capnp::Orphan< ::CacheArray> disownRoot();

  inline bool hasExpr();
  inline  ::CacheExpr::Builder getExpr();
  inline void setExpr( ::CacheExpr::Reader value);
  inline  ::CacheExpr::Builder initExpr();
  inline void adoptExpr(::capnp::Orphan< ::CacheExpr>&& value);
  inline ::capnp::Orphan< ::CacheExpr> disownExpr();

  inline bool hasHead();
  inline  ::CacheUpdateNode::Builder getHead();
  inline void setHead( ::CacheUpdateNode::Reader value);
  inline  ::CacheUpdateNode::Builder initHead();
  inline void adoptHead(::capnp::Orphan< ::CacheUpdateNode>&& value);
  inline ::capnp::Orphan< ::CacheUpdateNode> disownHead();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CacheReadExpr::Pipeline {
public:
  typedef CacheReadExpr Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::CacheArray::Pipeline getRoot();
  inline  ::CacheExpr::Pipeline getExpr();
  inline  ::CacheUpdateNode::Pipeline getHead();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CacheExpr::Reader {
public:
  typedef CacheExpr Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getWidth() const;

  inline  ::uint8_t getKind() const;

  inline bool hasKids() const;
  inline  ::capnp::List< ::CacheExpr>::Reader getKids() const;

  inline typename SpecialData::Reader getSpecialData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CacheExpr::Builder {
public:
  typedef CacheExpr Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getWidth();
  inline void setWidth( ::uint32_t value);

  inline  ::uint8_t getKind();
  inline void setKind( ::uint8_t value);

  inline bool hasKids();
  inline  ::capnp::List< ::CacheExpr>::Builder getKids();
  inline void setKids( ::capnp::List< ::CacheExpr>::Reader value);
  inline  ::capnp::List< ::CacheExpr>::Builder initKids(unsigned int size);
  inline void adoptKids(::capnp::Orphan< ::capnp::List< ::CacheExpr>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::CacheExpr>> disownKids();

  inline typename SpecialData::Builder getSpecialData();
  inline typename SpecialData::Builder initSpecialData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CacheExpr::Pipeline {
public:
  typedef CacheExpr Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename SpecialData::Pipeline getSpecialData();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CacheExpr::SpecialData::Reader {
public:
  typedef SpecialData Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isNothing() const;
  inline  ::capnp::Void getNothing() const;

  inline bool isConstData() const;
  inline bool hasConstData() const;
  inline  ::CacheConstExpr::Reader getConstData() const;

  inline bool isReadData() const;
  inline bool hasReadData() const;
  inline  ::CacheReadExpr::Reader getReadData() const;

  inline bool isExtractData() const;
  inline bool hasExtractData() const;
  inline  ::CacheExtractExpr::Reader getExtractData() const;

  inline bool isNOData() const;
  inline bool hasNOData() const;
  inline  ::CacheNotOptimisedExpr::Reader getNOData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CacheExpr::SpecialData::Builder {
public:
  typedef SpecialData Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isNothing();
  inline  ::capnp::Void getNothing();
  inline void setNothing( ::capnp::Void value = ::capnp::VOID);

  inline bool isConstData();
  inline bool hasConstData();
  inline  ::CacheConstExpr::Builder getConstData();
  inline void setConstData( ::CacheConstExpr::Reader value);
  inline  ::CacheConstExpr::Builder initConstData();
  inline void adoptConstData(::capnp::Orphan< ::CacheConstExpr>&& value);
  inline ::capnp::Orphan< ::CacheConstExpr> disownConstData();

  inline bool isReadData();
  inline bool hasReadData();
  inline  ::CacheReadExpr::Builder getReadData();
  inline void setReadData( ::CacheReadExpr::Reader value);
  inline  ::CacheReadExpr::Builder initReadData();
  inline void adoptReadData(::capnp::Orphan< ::CacheReadExpr>&& value);
  inline ::capnp::Orphan< ::CacheReadExpr> disownReadData();

  inline bool isExtractData();
  inline bool hasExtractData();
  inline  ::CacheExtractExpr::Builder getExtractData();
  inline void setExtractData( ::CacheExtractExpr::Reader value);
  inline  ::CacheExtractExpr::Builder initExtractData();
  inline void adoptExtractData(::capnp::Orphan< ::CacheExtractExpr>&& value);
  inline ::capnp::Orphan< ::CacheExtractExpr> disownExtractData();

  inline bool isNOData();
  inline bool hasNOData();
  inline  ::CacheNotOptimisedExpr::Builder getNOData();
  inline void setNOData( ::CacheNotOptimisedExpr::Reader value);
  inline  ::CacheNotOptimisedExpr::Builder initNOData();
  inline void adoptNOData(::capnp::Orphan< ::CacheNotOptimisedExpr>&& value);
  inline ::capnp::Orphan< ::CacheNotOptimisedExpr> disownNOData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CacheExpr::SpecialData::Pipeline {
public:
  typedef SpecialData Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CacheExprList::Reader {
public:
  typedef CacheExprList Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasKey() const;
  inline  ::capnp::List< ::CacheExpr>::Reader getKey() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CacheExprList::Builder {
public:
  typedef CacheExprList Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasKey();
  inline  ::capnp::List< ::CacheExpr>::Builder getKey();
  inline void setKey( ::capnp::List< ::CacheExpr>::Reader value);
  inline  ::capnp::List< ::CacheExpr>::Builder initKey(unsigned int size);
  inline void adoptKey(::capnp::Orphan< ::capnp::List< ::CacheExpr>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::CacheExpr>> disownKey();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CacheExprList::Pipeline {
public:
  typedef CacheExprList Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CapCache::Reader {
public:
  typedef CapCache Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasElems() const;
  inline  ::capnp::List< ::CapCache::Elem>::Reader getElems() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CapCache::Builder {
public:
  typedef CapCache Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasElems();
  inline  ::capnp::List< ::CapCache::Elem>::Builder getElems();
  inline void setElems( ::capnp::List< ::CapCache::Elem>::Reader value);
  inline  ::capnp::List< ::CapCache::Elem>::Builder initElems(unsigned int size);
  inline void adoptElems(::capnp::Orphan< ::capnp::List< ::CapCache::Elem>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::CapCache::Elem>> disownElems();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CapCache::Pipeline {
public:
  typedef CapCache Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CapCache::Elem::Reader {
public:
  typedef Elem Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasKey() const;
  inline  ::CacheExprList::Reader getKey() const;

  inline bool hasAssignment() const;
  inline  ::CacheAssignment::Reader getAssignment() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CapCache::Elem::Builder {
public:
  typedef Elem Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasKey();
  inline  ::CacheExprList::Builder getKey();
  inline void setKey( ::CacheExprList::Reader value);
  inline  ::CacheExprList::Builder initKey();
  inline void adoptKey(::capnp::Orphan< ::CacheExprList>&& value);
  inline ::capnp::Orphan< ::CacheExprList> disownKey();

  inline bool hasAssignment();
  inline  ::CacheAssignment::Builder getAssignment();
  inline void setAssignment( ::CacheAssignment::Reader value);
  inline  ::CacheAssignment::Builder initAssignment();
  inline void adoptAssignment(::capnp::Orphan< ::CacheAssignment>&& value);
  inline ::capnp::Orphan< ::CacheAssignment> disownAssignment();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CapCache::Elem::Pipeline {
public:
  typedef Elem Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::CacheExprList::Pipeline getKey();
  inline  ::CacheAssignment::Pipeline getAssignment();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool CacheArray::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CacheArray::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader CacheArray::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder CacheArray::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CacheArray::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder CacheArray::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void CacheArray::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> CacheArray::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t CacheArray::Reader::getSize() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t CacheArray::Builder::getSize() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CacheArray::Builder::setSize( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t CacheArray::Reader::getDomain() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CacheArray::Builder::getDomain() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void CacheArray::Builder::setDomain( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t CacheArray::Reader::getRange() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CacheArray::Builder::getRange() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void CacheArray::Builder::setRange( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool CacheArray::Reader::hasConstantValues() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CacheArray::Builder::hasConstantValues() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::CacheExpr>::Reader CacheArray::Reader::getConstantValues() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CacheExpr>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::CacheExpr>::Builder CacheArray::Builder::getConstantValues() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CacheExpr>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CacheArray::Builder::setConstantValues( ::capnp::List< ::CacheExpr>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::CacheExpr>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::CacheExpr>::Builder CacheArray::Builder::initConstantValues(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CacheExpr>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void CacheArray::Builder::adoptConstantValues(
    ::capnp::Orphan< ::capnp::List< ::CacheExpr>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::CacheExpr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::CacheExpr>> CacheArray::Builder::disownConstantValues() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CacheExpr>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool CacheAssignment::Reader::getAllowFreeValues() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool CacheAssignment::Builder::getAllowFreeValues() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CacheAssignment::Builder::setAllowFreeValues(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool CacheAssignment::Reader::hasBindings() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CacheAssignment::Builder::hasBindings() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::CacheAssignment::Binding>::Reader CacheAssignment::Reader::getBindings() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CacheAssignment::Binding>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::CacheAssignment::Binding>::Builder CacheAssignment::Builder::getBindings() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CacheAssignment::Binding>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CacheAssignment::Builder::setBindings( ::capnp::List< ::CacheAssignment::Binding>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::CacheAssignment::Binding>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::CacheAssignment::Binding>::Builder CacheAssignment::Builder::initBindings(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CacheAssignment::Binding>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void CacheAssignment::Builder::adoptBindings(
    ::capnp::Orphan< ::capnp::List< ::CacheAssignment::Binding>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::CacheAssignment::Binding>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::CacheAssignment::Binding>> CacheAssignment::Builder::disownBindings() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CacheAssignment::Binding>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CacheAssignment::Reader::getNoBinding() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool CacheAssignment::Builder::getNoBinding() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void CacheAssignment::Builder::setNoBinding(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool CacheAssignment::Binding::Reader::hasObjects() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CacheAssignment::Binding::Builder::hasObjects() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::CacheArray::Reader CacheAssignment::Binding::Reader::getObjects() const {
  return ::capnp::_::PointerHelpers< ::CacheArray>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::CacheArray::Builder CacheAssignment::Binding::Builder::getObjects() {
  return ::capnp::_::PointerHelpers< ::CacheArray>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::CacheArray::Pipeline CacheAssignment::Binding::Pipeline::getObjects() {
  return  ::CacheArray::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void CacheAssignment::Binding::Builder::setObjects( ::CacheArray::Reader value) {
  ::capnp::_::PointerHelpers< ::CacheArray>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::CacheArray::Builder CacheAssignment::Binding::Builder::initObjects() {
  return ::capnp::_::PointerHelpers< ::CacheArray>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CacheAssignment::Binding::Builder::adoptObjects(
    ::capnp::Orphan< ::CacheArray>&& value) {
  ::capnp::_::PointerHelpers< ::CacheArray>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::CacheArray> CacheAssignment::Binding::Builder::disownObjects() {
  return ::capnp::_::PointerHelpers< ::CacheArray>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CacheAssignment::Binding::Reader::hasBvs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CacheAssignment::Binding::Builder::hasBvs() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint8_t>::Reader CacheAssignment::Binding::Reader::getBvs() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint8_t>::Builder CacheAssignment::Binding::Builder::getBvs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CacheAssignment::Binding::Builder::setBvs( ::capnp::List< ::uint8_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void CacheAssignment::Binding::Builder::setBvs(::kj::ArrayPtr<const  ::uint8_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint8_t>::Builder CacheAssignment::Binding::Builder::initBvs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void CacheAssignment::Binding::Builder::adoptBvs(
    ::capnp::Orphan< ::capnp::List< ::uint8_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint8_t>> CacheAssignment::Binding::Builder::disownBvs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint32_t CacheConstExpr::Reader::getConstExprWidth() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CacheConstExpr::Builder::getConstExprWidth() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CacheConstExpr::Builder::setConstExprWidth( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t CacheConstExpr::Reader::getConstExprVal() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t CacheConstExpr::Builder::getConstExprVal() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void CacheConstExpr::Builder::setConstExprVal( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool CacheConstExpr::Reader::hasConstExprOverSizeVal() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CacheConstExpr::Builder::hasConstExprOverSizeVal() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader CacheConstExpr::Reader::getConstExprOverSizeVal() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder CacheConstExpr::Builder::getConstExprOverSizeVal() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CacheConstExpr::Builder::setConstExprOverSizeVal( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder CacheConstExpr::Builder::initConstExprOverSizeVal(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void CacheConstExpr::Builder::adoptConstExprOverSizeVal(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> CacheConstExpr::Builder::disownConstExprOverSizeVal() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t CacheExtractExpr::Reader::getExtractBitOff() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CacheExtractExpr::Builder::getExtractBitOff() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CacheExtractExpr::Builder::setExtractBitOff( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t CacheExtractExpr::Reader::getExtractWidth() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CacheExtractExpr::Builder::getExtractWidth() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void CacheExtractExpr::Builder::setExtractWidth( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool CacheExtractExpr::Reader::hasExpr() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CacheExtractExpr::Builder::hasExpr() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::CacheExpr::Reader CacheExtractExpr::Reader::getExpr() const {
  return ::capnp::_::PointerHelpers< ::CacheExpr>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::CacheExpr::Builder CacheExtractExpr::Builder::getExpr() {
  return ::capnp::_::PointerHelpers< ::CacheExpr>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::CacheExpr::Pipeline CacheExtractExpr::Pipeline::getExpr() {
  return  ::CacheExpr::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void CacheExtractExpr::Builder::setExpr( ::CacheExpr::Reader value) {
  ::capnp::_::PointerHelpers< ::CacheExpr>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::CacheExpr::Builder CacheExtractExpr::Builder::initExpr() {
  return ::capnp::_::PointerHelpers< ::CacheExpr>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CacheExtractExpr::Builder::adoptExpr(
    ::capnp::Orphan< ::CacheExpr>&& value) {
  ::capnp::_::PointerHelpers< ::CacheExpr>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::CacheExpr> CacheExtractExpr::Builder::disownExpr() {
  return ::capnp::_::PointerHelpers< ::CacheExpr>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CacheNotOptimisedExpr::Reader::hasSrc() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CacheNotOptimisedExpr::Builder::hasSrc() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::CacheExpr::Reader CacheNotOptimisedExpr::Reader::getSrc() const {
  return ::capnp::_::PointerHelpers< ::CacheExpr>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::CacheExpr::Builder CacheNotOptimisedExpr::Builder::getSrc() {
  return ::capnp::_::PointerHelpers< ::CacheExpr>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::CacheExpr::Pipeline CacheNotOptimisedExpr::Pipeline::getSrc() {
  return  ::CacheExpr::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void CacheNotOptimisedExpr::Builder::setSrc( ::CacheExpr::Reader value) {
  ::capnp::_::PointerHelpers< ::CacheExpr>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::CacheExpr::Builder CacheNotOptimisedExpr::Builder::initSrc() {
  return ::capnp::_::PointerHelpers< ::CacheExpr>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CacheNotOptimisedExpr::Builder::adoptSrc(
    ::capnp::Orphan< ::CacheExpr>&& value) {
  ::capnp::_::PointerHelpers< ::CacheExpr>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::CacheExpr> CacheNotOptimisedExpr::Builder::disownSrc() {
  return ::capnp::_::PointerHelpers< ::CacheExpr>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CacheUpdateNode::Reader::hasUpdateIndex() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CacheUpdateNode::Builder::hasUpdateIndex() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::CacheExpr::Reader CacheUpdateNode::Reader::getUpdateIndex() const {
  return ::capnp::_::PointerHelpers< ::CacheExpr>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::CacheExpr::Builder CacheUpdateNode::Builder::getUpdateIndex() {
  return ::capnp::_::PointerHelpers< ::CacheExpr>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::CacheExpr::Pipeline CacheUpdateNode::Pipeline::getUpdateIndex() {
  return  ::CacheExpr::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void CacheUpdateNode::Builder::setUpdateIndex( ::CacheExpr::Reader value) {
  ::capnp::_::PointerHelpers< ::CacheExpr>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::CacheExpr::Builder CacheUpdateNode::Builder::initUpdateIndex() {
  return ::capnp::_::PointerHelpers< ::CacheExpr>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CacheUpdateNode::Builder::adoptUpdateIndex(
    ::capnp::Orphan< ::CacheExpr>&& value) {
  ::capnp::_::PointerHelpers< ::CacheExpr>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::CacheExpr> CacheUpdateNode::Builder::disownUpdateIndex() {
  return ::capnp::_::PointerHelpers< ::CacheExpr>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CacheUpdateNode::Reader::hasUpdateValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CacheUpdateNode::Builder::hasUpdateValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::CacheExpr::Reader CacheUpdateNode::Reader::getUpdateValue() const {
  return ::capnp::_::PointerHelpers< ::CacheExpr>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::CacheExpr::Builder CacheUpdateNode::Builder::getUpdateValue() {
  return ::capnp::_::PointerHelpers< ::CacheExpr>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::CacheExpr::Pipeline CacheUpdateNode::Pipeline::getUpdateValue() {
  return  ::CacheExpr::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void CacheUpdateNode::Builder::setUpdateValue( ::CacheExpr::Reader value) {
  ::capnp::_::PointerHelpers< ::CacheExpr>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::CacheExpr::Builder CacheUpdateNode::Builder::initUpdateValue() {
  return ::capnp::_::PointerHelpers< ::CacheExpr>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CacheUpdateNode::Builder::adoptUpdateValue(
    ::capnp::Orphan< ::CacheExpr>&& value) {
  ::capnp::_::PointerHelpers< ::CacheExpr>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::CacheExpr> CacheUpdateNode::Builder::disownUpdateValue() {
  return ::capnp::_::PointerHelpers< ::CacheExpr>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool CacheUpdateNode::Reader::hasNext() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool CacheUpdateNode::Builder::hasNext() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::CacheUpdateNode::Reader CacheUpdateNode::Reader::getNext() const {
  return ::capnp::_::PointerHelpers< ::CacheUpdateNode>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::CacheUpdateNode::Builder CacheUpdateNode::Builder::getNext() {
  return ::capnp::_::PointerHelpers< ::CacheUpdateNode>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::CacheUpdateNode::Pipeline CacheUpdateNode::Pipeline::getNext() {
  return  ::CacheUpdateNode::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void CacheUpdateNode::Builder::setNext( ::CacheUpdateNode::Reader value) {
  ::capnp::_::PointerHelpers< ::CacheUpdateNode>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::CacheUpdateNode::Builder CacheUpdateNode::Builder::initNext() {
  return ::capnp::_::PointerHelpers< ::CacheUpdateNode>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void CacheUpdateNode::Builder::adoptNext(
    ::capnp::Orphan< ::CacheUpdateNode>&& value) {
  ::capnp::_::PointerHelpers< ::CacheUpdateNode>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::CacheUpdateNode> CacheUpdateNode::Builder::disownNext() {
  return ::capnp::_::PointerHelpers< ::CacheUpdateNode>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool CacheReadExpr::Reader::hasRoot() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CacheReadExpr::Builder::hasRoot() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::CacheArray::Reader CacheReadExpr::Reader::getRoot() const {
  return ::capnp::_::PointerHelpers< ::CacheArray>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::CacheArray::Builder CacheReadExpr::Builder::getRoot() {
  return ::capnp::_::PointerHelpers< ::CacheArray>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::CacheArray::Pipeline CacheReadExpr::Pipeline::getRoot() {
  return  ::CacheArray::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void CacheReadExpr::Builder::setRoot( ::CacheArray::Reader value) {
  ::capnp::_::PointerHelpers< ::CacheArray>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::CacheArray::Builder CacheReadExpr::Builder::initRoot() {
  return ::capnp::_::PointerHelpers< ::CacheArray>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CacheReadExpr::Builder::adoptRoot(
    ::capnp::Orphan< ::CacheArray>&& value) {
  ::capnp::_::PointerHelpers< ::CacheArray>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::CacheArray> CacheReadExpr::Builder::disownRoot() {
  return ::capnp::_::PointerHelpers< ::CacheArray>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CacheReadExpr::Reader::hasExpr() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CacheReadExpr::Builder::hasExpr() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::CacheExpr::Reader CacheReadExpr::Reader::getExpr() const {
  return ::capnp::_::PointerHelpers< ::CacheExpr>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::CacheExpr::Builder CacheReadExpr::Builder::getExpr() {
  return ::capnp::_::PointerHelpers< ::CacheExpr>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::CacheExpr::Pipeline CacheReadExpr::Pipeline::getExpr() {
  return  ::CacheExpr::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void CacheReadExpr::Builder::setExpr( ::CacheExpr::Reader value) {
  ::capnp::_::PointerHelpers< ::CacheExpr>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::CacheExpr::Builder CacheReadExpr::Builder::initExpr() {
  return ::capnp::_::PointerHelpers< ::CacheExpr>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CacheReadExpr::Builder::adoptExpr(
    ::capnp::Orphan< ::CacheExpr>&& value) {
  ::capnp::_::PointerHelpers< ::CacheExpr>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::CacheExpr> CacheReadExpr::Builder::disownExpr() {
  return ::capnp::_::PointerHelpers< ::CacheExpr>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool CacheReadExpr::Reader::hasHead() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool CacheReadExpr::Builder::hasHead() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::CacheUpdateNode::Reader CacheReadExpr::Reader::getHead() const {
  return ::capnp::_::PointerHelpers< ::CacheUpdateNode>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::CacheUpdateNode::Builder CacheReadExpr::Builder::getHead() {
  return ::capnp::_::PointerHelpers< ::CacheUpdateNode>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::CacheUpdateNode::Pipeline CacheReadExpr::Pipeline::getHead() {
  return  ::CacheUpdateNode::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void CacheReadExpr::Builder::setHead( ::CacheUpdateNode::Reader value) {
  ::capnp::_::PointerHelpers< ::CacheUpdateNode>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::CacheUpdateNode::Builder CacheReadExpr::Builder::initHead() {
  return ::capnp::_::PointerHelpers< ::CacheUpdateNode>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void CacheReadExpr::Builder::adoptHead(
    ::capnp::Orphan< ::CacheUpdateNode>&& value) {
  ::capnp::_::PointerHelpers< ::CacheUpdateNode>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::CacheUpdateNode> CacheReadExpr::Builder::disownHead() {
  return ::capnp::_::PointerHelpers< ::CacheUpdateNode>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::uint32_t CacheExpr::Reader::getWidth() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CacheExpr::Builder::getWidth() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CacheExpr::Builder::setWidth( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t CacheExpr::Reader::getKind() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t CacheExpr::Builder::getKind() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void CacheExpr::Builder::setKind( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool CacheExpr::Reader::hasKids() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CacheExpr::Builder::hasKids() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::CacheExpr>::Reader CacheExpr::Reader::getKids() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CacheExpr>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::CacheExpr>::Builder CacheExpr::Builder::getKids() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CacheExpr>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CacheExpr::Builder::setKids( ::capnp::List< ::CacheExpr>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::CacheExpr>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::CacheExpr>::Builder CacheExpr::Builder::initKids(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CacheExpr>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void CacheExpr::Builder::adoptKids(
    ::capnp::Orphan< ::capnp::List< ::CacheExpr>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::CacheExpr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::CacheExpr>> CacheExpr::Builder::disownKids() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CacheExpr>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline typename CacheExpr::SpecialData::Reader CacheExpr::Reader::getSpecialData() const {
  return typename CacheExpr::SpecialData::Reader(_reader);
}
inline typename CacheExpr::SpecialData::Builder CacheExpr::Builder::getSpecialData() {
  return typename CacheExpr::SpecialData::Builder(_builder);
}
#if !CAPNP_LITE
inline typename CacheExpr::SpecialData::Pipeline CacheExpr::Pipeline::getSpecialData() {
  return typename CacheExpr::SpecialData::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename CacheExpr::SpecialData::Builder CacheExpr::Builder::initSpecialData() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<3>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).clear();
  return typename CacheExpr::SpecialData::Builder(_builder);
}
inline  ::CacheExpr::SpecialData::Which CacheExpr::SpecialData::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline  ::CacheExpr::SpecialData::Which CacheExpr::SpecialData::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline bool CacheExpr::SpecialData::Reader::isNothing() const {
  return which() == CacheExpr::SpecialData::NOTHING;
}
inline bool CacheExpr::SpecialData::Builder::isNothing() {
  return which() == CacheExpr::SpecialData::NOTHING;
}
inline  ::capnp::Void CacheExpr::SpecialData::Reader::getNothing() const {
  KJ_IREQUIRE((which() == CacheExpr::SpecialData::NOTHING),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void CacheExpr::SpecialData::Builder::getNothing() {
  KJ_IREQUIRE((which() == CacheExpr::SpecialData::NOTHING),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CacheExpr::SpecialData::Builder::setNothing( ::capnp::Void value) {
  _builder.setDataField<CacheExpr::SpecialData::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, CacheExpr::SpecialData::NOTHING);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool CacheExpr::SpecialData::Reader::isConstData() const {
  return which() == CacheExpr::SpecialData::CONST_DATA;
}
inline bool CacheExpr::SpecialData::Builder::isConstData() {
  return which() == CacheExpr::SpecialData::CONST_DATA;
}
inline bool CacheExpr::SpecialData::Reader::hasConstData() const {
  if (which() != CacheExpr::SpecialData::CONST_DATA) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CacheExpr::SpecialData::Builder::hasConstData() {
  if (which() != CacheExpr::SpecialData::CONST_DATA) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::CacheConstExpr::Reader CacheExpr::SpecialData::Reader::getConstData() const {
  KJ_IREQUIRE((which() == CacheExpr::SpecialData::CONST_DATA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::CacheConstExpr>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::CacheConstExpr::Builder CacheExpr::SpecialData::Builder::getConstData() {
  KJ_IREQUIRE((which() == CacheExpr::SpecialData::CONST_DATA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::CacheConstExpr>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CacheExpr::SpecialData::Builder::setConstData( ::CacheConstExpr::Reader value) {
  _builder.setDataField<CacheExpr::SpecialData::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, CacheExpr::SpecialData::CONST_DATA);
  ::capnp::_::PointerHelpers< ::CacheConstExpr>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::CacheConstExpr::Builder CacheExpr::SpecialData::Builder::initConstData() {
  _builder.setDataField<CacheExpr::SpecialData::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, CacheExpr::SpecialData::CONST_DATA);
  return ::capnp::_::PointerHelpers< ::CacheConstExpr>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CacheExpr::SpecialData::Builder::adoptConstData(
    ::capnp::Orphan< ::CacheConstExpr>&& value) {
  _builder.setDataField<CacheExpr::SpecialData::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, CacheExpr::SpecialData::CONST_DATA);
  ::capnp::_::PointerHelpers< ::CacheConstExpr>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::CacheConstExpr> CacheExpr::SpecialData::Builder::disownConstData() {
  KJ_IREQUIRE((which() == CacheExpr::SpecialData::CONST_DATA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::CacheConstExpr>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool CacheExpr::SpecialData::Reader::isReadData() const {
  return which() == CacheExpr::SpecialData::READ_DATA;
}
inline bool CacheExpr::SpecialData::Builder::isReadData() {
  return which() == CacheExpr::SpecialData::READ_DATA;
}
inline bool CacheExpr::SpecialData::Reader::hasReadData() const {
  if (which() != CacheExpr::SpecialData::READ_DATA) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CacheExpr::SpecialData::Builder::hasReadData() {
  if (which() != CacheExpr::SpecialData::READ_DATA) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::CacheReadExpr::Reader CacheExpr::SpecialData::Reader::getReadData() const {
  KJ_IREQUIRE((which() == CacheExpr::SpecialData::READ_DATA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::CacheReadExpr>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::CacheReadExpr::Builder CacheExpr::SpecialData::Builder::getReadData() {
  KJ_IREQUIRE((which() == CacheExpr::SpecialData::READ_DATA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::CacheReadExpr>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CacheExpr::SpecialData::Builder::setReadData( ::CacheReadExpr::Reader value) {
  _builder.setDataField<CacheExpr::SpecialData::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, CacheExpr::SpecialData::READ_DATA);
  ::capnp::_::PointerHelpers< ::CacheReadExpr>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::CacheReadExpr::Builder CacheExpr::SpecialData::Builder::initReadData() {
  _builder.setDataField<CacheExpr::SpecialData::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, CacheExpr::SpecialData::READ_DATA);
  return ::capnp::_::PointerHelpers< ::CacheReadExpr>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CacheExpr::SpecialData::Builder::adoptReadData(
    ::capnp::Orphan< ::CacheReadExpr>&& value) {
  _builder.setDataField<CacheExpr::SpecialData::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, CacheExpr::SpecialData::READ_DATA);
  ::capnp::_::PointerHelpers< ::CacheReadExpr>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::CacheReadExpr> CacheExpr::SpecialData::Builder::disownReadData() {
  KJ_IREQUIRE((which() == CacheExpr::SpecialData::READ_DATA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::CacheReadExpr>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool CacheExpr::SpecialData::Reader::isExtractData() const {
  return which() == CacheExpr::SpecialData::EXTRACT_DATA;
}
inline bool CacheExpr::SpecialData::Builder::isExtractData() {
  return which() == CacheExpr::SpecialData::EXTRACT_DATA;
}
inline bool CacheExpr::SpecialData::Reader::hasExtractData() const {
  if (which() != CacheExpr::SpecialData::EXTRACT_DATA) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CacheExpr::SpecialData::Builder::hasExtractData() {
  if (which() != CacheExpr::SpecialData::EXTRACT_DATA) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::CacheExtractExpr::Reader CacheExpr::SpecialData::Reader::getExtractData() const {
  KJ_IREQUIRE((which() == CacheExpr::SpecialData::EXTRACT_DATA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::CacheExtractExpr>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::CacheExtractExpr::Builder CacheExpr::SpecialData::Builder::getExtractData() {
  KJ_IREQUIRE((which() == CacheExpr::SpecialData::EXTRACT_DATA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::CacheExtractExpr>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CacheExpr::SpecialData::Builder::setExtractData( ::CacheExtractExpr::Reader value) {
  _builder.setDataField<CacheExpr::SpecialData::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, CacheExpr::SpecialData::EXTRACT_DATA);
  ::capnp::_::PointerHelpers< ::CacheExtractExpr>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::CacheExtractExpr::Builder CacheExpr::SpecialData::Builder::initExtractData() {
  _builder.setDataField<CacheExpr::SpecialData::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, CacheExpr::SpecialData::EXTRACT_DATA);
  return ::capnp::_::PointerHelpers< ::CacheExtractExpr>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CacheExpr::SpecialData::Builder::adoptExtractData(
    ::capnp::Orphan< ::CacheExtractExpr>&& value) {
  _builder.setDataField<CacheExpr::SpecialData::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, CacheExpr::SpecialData::EXTRACT_DATA);
  ::capnp::_::PointerHelpers< ::CacheExtractExpr>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::CacheExtractExpr> CacheExpr::SpecialData::Builder::disownExtractData() {
  KJ_IREQUIRE((which() == CacheExpr::SpecialData::EXTRACT_DATA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::CacheExtractExpr>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool CacheExpr::SpecialData::Reader::isNOData() const {
  return which() == CacheExpr::SpecialData::N_O_DATA;
}
inline bool CacheExpr::SpecialData::Builder::isNOData() {
  return which() == CacheExpr::SpecialData::N_O_DATA;
}
inline bool CacheExpr::SpecialData::Reader::hasNOData() const {
  if (which() != CacheExpr::SpecialData::N_O_DATA) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CacheExpr::SpecialData::Builder::hasNOData() {
  if (which() != CacheExpr::SpecialData::N_O_DATA) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::CacheNotOptimisedExpr::Reader CacheExpr::SpecialData::Reader::getNOData() const {
  KJ_IREQUIRE((which() == CacheExpr::SpecialData::N_O_DATA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::CacheNotOptimisedExpr>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::CacheNotOptimisedExpr::Builder CacheExpr::SpecialData::Builder::getNOData() {
  KJ_IREQUIRE((which() == CacheExpr::SpecialData::N_O_DATA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::CacheNotOptimisedExpr>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CacheExpr::SpecialData::Builder::setNOData( ::CacheNotOptimisedExpr::Reader value) {
  _builder.setDataField<CacheExpr::SpecialData::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, CacheExpr::SpecialData::N_O_DATA);
  ::capnp::_::PointerHelpers< ::CacheNotOptimisedExpr>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::CacheNotOptimisedExpr::Builder CacheExpr::SpecialData::Builder::initNOData() {
  _builder.setDataField<CacheExpr::SpecialData::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, CacheExpr::SpecialData::N_O_DATA);
  return ::capnp::_::PointerHelpers< ::CacheNotOptimisedExpr>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CacheExpr::SpecialData::Builder::adoptNOData(
    ::capnp::Orphan< ::CacheNotOptimisedExpr>&& value) {
  _builder.setDataField<CacheExpr::SpecialData::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, CacheExpr::SpecialData::N_O_DATA);
  ::capnp::_::PointerHelpers< ::CacheNotOptimisedExpr>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::CacheNotOptimisedExpr> CacheExpr::SpecialData::Builder::disownNOData() {
  KJ_IREQUIRE((which() == CacheExpr::SpecialData::N_O_DATA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::CacheNotOptimisedExpr>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool CacheExprList::Reader::hasKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CacheExprList::Builder::hasKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::CacheExpr>::Reader CacheExprList::Reader::getKey() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CacheExpr>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::CacheExpr>::Builder CacheExprList::Builder::getKey() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CacheExpr>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CacheExprList::Builder::setKey( ::capnp::List< ::CacheExpr>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::CacheExpr>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::CacheExpr>::Builder CacheExprList::Builder::initKey(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CacheExpr>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void CacheExprList::Builder::adoptKey(
    ::capnp::Orphan< ::capnp::List< ::CacheExpr>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::CacheExpr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::CacheExpr>> CacheExprList::Builder::disownKey() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CacheExpr>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CapCache::Reader::hasElems() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CapCache::Builder::hasElems() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::CapCache::Elem>::Reader CapCache::Reader::getElems() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CapCache::Elem>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::CapCache::Elem>::Builder CapCache::Builder::getElems() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CapCache::Elem>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CapCache::Builder::setElems( ::capnp::List< ::CapCache::Elem>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::CapCache::Elem>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::CapCache::Elem>::Builder CapCache::Builder::initElems(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CapCache::Elem>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void CapCache::Builder::adoptElems(
    ::capnp::Orphan< ::capnp::List< ::CapCache::Elem>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::CapCache::Elem>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::CapCache::Elem>> CapCache::Builder::disownElems() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CapCache::Elem>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CapCache::Elem::Reader::hasKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CapCache::Elem::Builder::hasKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::CacheExprList::Reader CapCache::Elem::Reader::getKey() const {
  return ::capnp::_::PointerHelpers< ::CacheExprList>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::CacheExprList::Builder CapCache::Elem::Builder::getKey() {
  return ::capnp::_::PointerHelpers< ::CacheExprList>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::CacheExprList::Pipeline CapCache::Elem::Pipeline::getKey() {
  return  ::CacheExprList::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void CapCache::Elem::Builder::setKey( ::CacheExprList::Reader value) {
  ::capnp::_::PointerHelpers< ::CacheExprList>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::CacheExprList::Builder CapCache::Elem::Builder::initKey() {
  return ::capnp::_::PointerHelpers< ::CacheExprList>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CapCache::Elem::Builder::adoptKey(
    ::capnp::Orphan< ::CacheExprList>&& value) {
  ::capnp::_::PointerHelpers< ::CacheExprList>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::CacheExprList> CapCache::Elem::Builder::disownKey() {
  return ::capnp::_::PointerHelpers< ::CacheExprList>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CapCache::Elem::Reader::hasAssignment() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CapCache::Elem::Builder::hasAssignment() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::CacheAssignment::Reader CapCache::Elem::Reader::getAssignment() const {
  return ::capnp::_::PointerHelpers< ::CacheAssignment>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::CacheAssignment::Builder CapCache::Elem::Builder::getAssignment() {
  return ::capnp::_::PointerHelpers< ::CacheAssignment>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::CacheAssignment::Pipeline CapCache::Elem::Pipeline::getAssignment() {
  return  ::CacheAssignment::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void CapCache::Elem::Builder::setAssignment( ::CacheAssignment::Reader value) {
  ::capnp::_::PointerHelpers< ::CacheAssignment>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::CacheAssignment::Builder CapCache::Elem::Builder::initAssignment() {
  return ::capnp::_::PointerHelpers< ::CacheAssignment>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CapCache::Elem::Builder::adoptAssignment(
    ::capnp::Orphan< ::CacheAssignment>&& value) {
  ::capnp::_::PointerHelpers< ::CacheAssignment>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::CacheAssignment> CapCache::Elem::Builder::disownAssignment() {
  return ::capnp::_::PointerHelpers< ::CacheAssignment>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}


#endif  // CAPNP_INCLUDED_c8927f547a124ed2_
